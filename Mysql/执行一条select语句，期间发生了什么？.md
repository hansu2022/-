![[Pasted image 20250921143903.png]]
#### 简要回答

1. **连接阶段**：由服务器端的**连接器**组件负责，在客户端与 MySQL 服务器之间建立连接，并验证用户权限。
2. **查询缓存**（仅限 MySQL 8.0 前）：检查**是否命中缓存**，若有完全相同且有效的查询结果可以直接返回。
3. **解析与预处理**：解析 SQL 语法，检查语法是否正确，并生成抽象语法树，然后，**预处理器**进行一些语义检查，验证表和字段是否存在。
4. **优化器**：基于统计信息和成本模型，考虑多种执行方案，并选择最优执行计划（如索引选择、JOIN 顺序）。
5. **执行器**：根据选择的执行计划，调用存储引擎接口，并按执行计划读取数据并处理（排序、聚合等）。
6. **存储引擎**（如 InnoDB）：负责从磁盘或内存读取数据，返回给执行器。
7. **返回结果**：执行器进行必要的处理（如过滤、排序）后，将结果集返回客户端，可能分批次传输。




### 1. Server 层
这一层是 MySQL 的大脑，负责处理所有的 SQL 查询。它像一个调度中心，处理从连接到执行的整个过程。
#### **主要功能模块：**
- **连接器**：管理客户端的连接，包括权限验证。
- **查询缓存**（MySQL 8.0 已移除）：在旧版本中，如果查询的结果在缓存中，可以直接返回，避免了后续的解析和执行。
- **解析器**：分析 SQL 语句的语法是否正确，并生成一个“解析树”。
- **预处理器**：对解析器生成的解析树进行进一步检查，例如验证表名和字段是否存在。
- **优化器**：为你的 SQL 语句找到**最优的执行方案**，比如决定使用哪个索引、表连接的顺序等等。
- **执行器**：根据优化器生成的执行计划，调用存储引擎提供的接口来完成具体的数据读写操作。

此外，所有跨存储引擎的功能，如**内置函数**（如 `NOW()`、`RAND()`）、**存储过程**和**触发器**，也都在这一层实现。

### 2. 存储引擎层

这一层是 MySQL 的心脏，负责数据的**实际存储和提取**。不同的存储引擎可以理解为不同的“仓库管理员”，各自有不同的存储方式和功能特点，但都共用同一个 Server 层。

- **多引擎支持**：MySQL 支持多种存储引擎，如 **InnoDB**、**MyISAM** 和 **Memory** 等。
- **InnoDB**：这是目前最常用和推荐的存储引擎，从 MySQL 5.5 版本开始，它就成为了默认的存储引擎。它最大的特点是支持**事务处理**、**行级锁**和**外键**，保证了数据的高可靠性。
- **索引实现**：我们经常提到的**索引**（如 B+ 树），其具体的数据结构和实现就位于这一层。不同的存储引擎支持的索引类型也可能不同。例如，InnoDB 默认使用的是 **B+ 树索引**，无论是主键索引还是二级索引，都是基于 B+ 树实现的。

好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。

## 第一步：连接器

如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：

```
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h$ip -u$user -p
```

#### **身份验证与权限**

- **用户名与密码**：TCP 连接建立后，连接器会验证你提供的用户名和密码。如果错误，会返回 "Access denied" 错误。
- **权限获取**：如果用户名和密码都正确，连接器会**获取该用户的所有权限**并将其保存在这个连接中。
- **权限的即时性**：**连接的权限是固定的**。即使管理员在连接建立后修改了该用户的权限，这个已有的连接也不会受到影响，只有新建立的连接才会使用新的权限。
连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF.png)

> 如何查看 MySQL 服务被多少个客户端连接了？

如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 `show processlist` 命令进行查看。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png)

比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 `Sleep` ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。
- **空闲连接**：空闲连接不会一直存在，MySQL 通过 `wait_timeout` 参数来控制空闲连接的最大时长，默认是 8 小时。超过这个时间，连接会自动断开。
    
- **手动断开**：你可以使用 `kill connection + id` 命令手动断开指定的连接。
    
- **最大连接数**：MySQL 服务支持的最大连接数由 `max_connections` 参数控制，默认值为 151。超过这个值，新的连接会被拒绝。

MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：

```
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

#### **长连接与短连接**

- **区别**：
    - **短连接**：每次执行 SQL 都需要重新建立和断开连接。
    - **长连接**：在一次连接中重复执行多次 SQL 语句，直到最后才断开。
- **优点**：长连接可以减少频繁建立和断开连接的开销，效率更高。
- **缺点**：长连接在执行查询时会占用内存，如果连接数过多且长时间不关闭，可能会导致 MySQL 服务内存占用过大，甚至被系统强制终止。
- **长连接的内存问题解决方案**：
    - **定期断开**：客户端可以定期主动断开长连接。
    - **重置连接**：使用 `mysql_reset_connection()` 函数（MySQL 5.7+ 版本提供）。这个函数可以重置连接状态，释放内存资源，而无需重新建立连接和进行权限验证。
## 第二步：查询缓存
当客户端连接建立并发送 SQL 语句后，如果是一个 `SELECT` 查询，MySQL 会进入查询缓存（Query Cache）阶段。
#### **工作原理**
- 查询缓存以**键值对（Key-Value）**的形式存储在内存中。
- **Key**：完整的 SQL 查询语句。
- **Value**：查询结果。
- 当一条 SQL 查询到达时，MySQL 会先检查查询缓存中是否有完全相同的 SQL 语句。
    - 如果**命中**，MySQL 直接将缓存中的结果返回给客户端，而无需进行后续的解析、优化和执行。
    - 如果**未命中**，MySQL 会继续执行后面的步骤，并在最终获取查询结果后，将其存入查询缓存以备后用。
#### **为什么查询缓存“鸡肋”？**

尽管查询缓存听起来很高效，但它有一个致命的缺点：**只要对任何一张表进行了更新（`INSERT`、`DELETE`、`UPDATE`）操作，所有与这张表相关的查询缓存都会被清空**。

- 这意味着，对于那些数据经常变动的表，查询缓存的命中率会非常低。
- 如果一个复杂的查询结果刚被缓存，表就发生了更新，那么这个缓存瞬间就失效了，浪费了内存资源和缓存操作本身的时间。
#### **查询缓存的现状**

- 正是由于命中率低和维护成本高，**MySQL 8.0 版本已经彻底移除了查询缓存**。
- 对于使用 MySQL 8.0 之前的版本，可以通过将 `query_cache_type` 参数设置为 `DEMAND` 来关闭查询缓存。

> **小贴士**：这里提到的查询缓存是 **Server 层**的功能，它和 InnoDB 存储引擎中的 **Buffer Pool** 是完全不同的概念。Buffer Pool 是 InnoDB 存储引擎用来缓存数据页和索引页的地方，它是 InnoDB 性能优化的核心，并不会被移除。
## 第三步：解析 SQL

在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。

### 解析器

解析器会做如下两件事情。

这个阶段就像一个“分词器”，它会扫描你输入的 SQL 语句，从中识别出每一个独立的词（称为 Token）。它能区分出**关键字**（如 `SELECT`、`FROM`）和**非关键字**（如表名、字段名）。

- **例如**：`SELECT username FROM userinfo` 这条语句会被解析器分解成 `SELECT`、`username`、`FROM`、`userinfo` 这四个 Token。

|关键字|非关键字|关键字|非关键字|
|---|---|---|---|
|select|username|from|userinfo|

第二件事情，**语法分析**。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，**作用**：这个语法树是一个结构化的数据，方便后续的模块（如预处理器、优化器）轻松获取 SQL 语句的类型、涉及的表名、字段名以及查询条件等信息。

![img](https://cdn.xiaolincoding.com//picgo/db-mysql-sql-parser-2.png)

如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png)

MySQL 的解析器**只负责检查语法和构建语法树**。它并不会去验证表或字段是否存在。这个任务将由后续的**预处理器**来完成。
## 第四步：执行 SQL

当 SQL 语句通过了解析器的检查后，它将进入实际的执行流程，主要分为三个阶段：**预处理**（Prepare）、**优化**（Optimize）和**执行**（Execute）。

### **1. 预处理器 (Prepare)**

这是 SQL 执行前的“准备”阶段，主要负责：

- **检查表和字段是否存在**：这是预处理器的核心任务。如果 SQL 语句中引用的表或字段不存在，MySQL 会在这个阶段报错。
    
- **星号展开**：将 `SELECT *` 中的 `*` 符号替换成该表的所有列名，以便后续处理。

我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。

```
mysql> select * from test;
ERROR 1146 (42S02): Table 'mysql.test' doesn't exist
```

> **小贴士**：值得注意的是，**MySQL 8.0** 版本已将检查表和字段是否存在的工作放在了 `prepare` 阶段。而在 **MySQL 5.7** 版本中，这个工作在解析器之后，但同样在 `prepare` 之前完成，结论都是**不在解析器内部**。

### 优化器

预处理器完成任务后，优化器会登场，为 SQL 语句制定**最优的执行方案**。

- **核心任务**：选择最佳的执行路径，尤其是在有多条路径可选时（例如，表中存在多个索引）。
    
- **如何选择**：优化器会基于**查询成本**（Cost-based）来决定。它会评估不同执行方案的代价，比如扫描的行数、是否使用索引等，然后选择成本最小的方案。
    
- **`EXPLAIN` 命令**：通过在查询语句前加上 `EXPLAIN`，可以查看优化器为该语句制定的执行计划，包括它选择了哪个索引（`key` 列）。
    
    - `key` 列显示使用的索引。如果为 `NULL`，表示没有使用索引，可能会进行**全表扫描**（`type = ALL`）。
        
- **覆盖索引**：当一个查询的所有数据都可以直接从**二级索引**的叶子节点中获取（因为二级索引本身存储了主键值），而无需回表到主键索引去查找完整的数据行时，就称为**覆盖索引**。优化器会优先选择这种查询成本更低的方案，这在 `EXPLAIN` 结果中会显示 `Using index`。
-  **常见的优化策略包括**： ① 选择合适的索引。 ② 决定表的连接顺序。 ③ 选择合适的连接算法（如嵌套循环连接、哈希连接、合并排序连接）。 ④ 改写查询语句，使其更高效。
1. **面试官可能的追问—优化器如何决定使用某个索引？**
    - **答**：基于索引的选择性（唯一性）、统计信息（基数）和查询条件。可通过 `EXPLAIN` 查看 `possible_keys` 和 `key` 字段。
2. **面试官可能的追问—如何分析一条慢 SQL 的执行瓶颈？**
    - **答**： ① 使用 `EXPLAIN` 查看执行计划（索引使用、扫描行数）。 ② 开启慢查询日志（`slow_query_log`）捕获耗时操作。 ③ 检查锁竞争（`SHOW ENGINE INNODB STATUS`）。
比如下图的 key 为 `PRIMARY` 就是使用了主键索引。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png)

如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的，如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png)

这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E4%BA%A7%E5%93%81%E8%A1%A8.png)

这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：

```
select id from product where id > 1  and name like 'i%';
```

这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。
很显然这条查询语句是**覆盖索引**，
**覆盖索引**：当一个查询的所有数据都可以直接从**二级索引**的叶子节点中获取（因为二级索引本身存储了主键值），而无需回表到主键索引去查找完整的数据行时，就称为**覆盖索引**。优化器会优先选择这种查询成本更低的方案，这在 `EXPLAIN` 结果中会显示 `Using index`。
在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95.png)

### ### **MySQL 执行器**

当优化器制定好执行计划后，**执行器**开始工作。它负责**执行**这个计划，并与**存储引擎**进行交互，这个交互是以**记录（行**为单位的。

下面我们通过三种不同的查询方式，来理解执行器和存储引擎是如何协作的。

#### **1. 主键索引查询**

以 `select * from product where id = 1;` 为例：

当执行像 `SELECT * FROM product WHERE id = 1;` 这样的查询时，由于 `id` 是主键且查询条件为等值匹配，**优化器**会选择最高效的 **`const`** 访问类型，这意味着它会通过主键索引直接定位到唯一的记录。

在这种情况下，**执行器**与**存储引擎**的交互流程如下：
#### **1. 首次查询**

- **执行器发起请求**：执行器调用一个特定的函数指针 `read_first_record`。
- **函数指向**：由于优化器选择了 `const` 访问类型，这个指针会指向 **InnoDB 存储引擎**用于索引查询的接口。
- **传递条件**：执行器将 `id = 1` 这个查询条件传递给存储引擎。
- **存储引擎定位**：存储引擎利用**主键索引的 B+ 树**结构，快速定位到 `id` 为 1 的那条记录。
- **返回结果**：
    - 如果记录**不存在**，存储引擎会向执行器返回“记录未找到”的错误，查询立即结束。
    - 如果记录**存在**，存储引擎将该记录返回给执行器。
        
#### **2. 执行器处理结果**

- **条件判断**：执行器收到记录后，会再次判断它是否符合查询条件。在主键等值查询中，这一步通常是多余的，但这是执行器通用流程的一部分。
- **发送给客户端**：如果记录符合条件，执行器会将该记录发送给客户端。
#### **3. 结束查询**
- **继续循环**：执行器的工作在一个 `while` 循环中进行，所以它还会尝试读取下一条记录。
- **调用 `read_record`**：这一次，执行器会调用另一个函数指针 `read_record`。
- **特殊返回**：因为是 `const` 访问类型，`read_record` 指向一个永远返回 `-1` 的特殊函数。
- **退出循环**：当 `read_record` 函数返回 `-1` 时，执行器会退出循环，标志着整个查询过程的结束。

简单来说，对于主键等值查询，执行器只需向存储引擎请求一次，获取到唯一的记录后，就立即结束查询，整个过程非常高效。

#### **2. 全表扫描**

以 `select * from product where name = 'iphone';` 为例：

1. **执行器启动**：执行器调用存储引擎的接口，要求它读取表中的**第一条记录**。
    
2. **存储引擎返回**：存储引擎读取第一条记录并返回给执行器。
    
3. **执行器判断**：执行器接收到记录后，判断它的 `name` 字段是否等于 `'iphone'`。
    
    - 如果**符合**，则将记录发送给客户端。
        
    - 如果**不符合**，则直接跳过。
        
4. **循环读取**：执行器会持续向存储引擎要**下一条记录**。这个过程会一直重复，直到存储引擎将表中的**所有记录**都返回给执行器。
    
5. **结束**：当所有记录都被处理完毕后，执行器退出循环，查询结束。

#### **3. 索引下推 (Index Condition Pushdown)**

索引下推是 MySQL 5.6 引入的优化策略，它能减少**回表**操作，将部分过滤工作下推到**存储引擎层**。

- **场景**：主要应用于**联合索引**。当联合索引遇到范围查询时，索引只能匹配到一部分，无法完全过滤。
    
- **示例**：假设在 `t_user` 表上有一个联合索引 `(age, reward)`，执行 `select * from t_user where age > 20 and reward = 100000;`。`age` 可以用到索引，但 `reward` 无法完全利用。
    
- **没有索引下推（旧版本）**：
    
    1. 存储引擎根据 `age > 20` 定位到第一条符合条件的索引记录。
        
    2. 每找到一条索引记录，就立即**回表**获取**整条数据**。
        
    3. 将完整的记录返回给执行器。
        
    4. 执行器在 Server 层判断 `reward = 100000` 是否成立。
        
    
    - **缺点**：即使 `reward` 不符合条件，也进行了多次不必要的回表操作。
        
- **使用索引下推（MySQL 5.6+）**：
    
    1. 存储引擎根据 `age > 20` 定位到第一条符合条件的索引记录。
        
    2. **不急于回表**，而是在**存储引擎层**，利用索引中包含的 `reward` 字段，直接判断 `reward = 100000` 是否成立。
        
    3. 如果**条件成立**，才进行回表操作，将完整的记录返回给执行器。
        
    4. 如果**条件不成立**，直接跳过该索引记录，继续向后扫描，避免了回表。
        
    
    - **优点**：显著减少了回表次数，提高了查询效率。
        
- **判断依据**：当 `EXPLAIN` 结果的 `Extra` 列显示 **"Using index condition"** 时，就表示使用了索引下推。

## 总结
### **执行一条 SQL 查询语句，期间发生了什么？**

整个流程可以分为两大层：**Server 层** 和 **存储引擎层**。

**Server 层**主要负责 SQL 的解析、优化和执行：

- **1. 连接器**：负责客户端的连接管理、**身份验证**和**权限分配**。用户的权限在连接建立时就被确定，中途修改不会影响已有的连接。
    
- **2. 查询缓存**：检查缓存中是否已有该 SQL 语句的查询结果。如果**命中**则直接返回。
    
    > **注意**：MySQL 8.0 版本已**移除**此功能。
    
- **3. 解析器**：对 SQL 语句进行**词法分析**和**语法分析**，生成抽象语法树，确保语句符合语法规则。
    
- **4. 预处理器**：检查语法树中的表和字段是否存在，并展开 `SELECT *` 中的星号。
    
- **5. 优化器**：根据**查询成本**选择最优的**执行计划**，例如决定使用哪个索引。
    
- **6. 执行器**：根据优化器生成的执行计划，调用存储引擎的接口，以**逐行**的方式从表中获取数据。