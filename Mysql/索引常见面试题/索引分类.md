### **一、按数据结构分类的常见索引类型**

从数据结构的角度，MySQL 常见的索引类型主要有以下三种：

- **B+Tree 索引**：MySQL 最常用、也是 InnoDB 和 MyISAM 存储引擎默认支持的索引类型。其数据结构为 B+Tree。
    
- **HASH 索引**：主要由 Memory 存储引擎支持。其数据结构为哈希表。
    
- **Full-Text 索引**：全文索引，用于进行文本内容的模糊查询。
![[Pasted image 20250923134456.png]]
### **二、B+Tree 索引详解**

B+Tree 是 MySQL 存储引擎采用最多的索引类型，尤其在 **InnoDB** 存储引擎中，B+Tree 索引是其核心。
#### **1. InnoDB 存储引擎中 B+Tree 索引的分类**
在 InnoDB 存储引擎中，B+Tree 索引分为两大类：
- **聚簇索引（Clustered Index）**：
    - **定义**：聚簇索引的叶子节点直接存放着完整的行数据。
    - **索引键（key）选择规则**：InnoDB 会根据以下优先级自动选择聚簇索引的索引键：
        1. 如果表定义了主键（`PRIMARY KEY`），主键将作为聚簇索引的索引键。
        2. 如果没有主键，则选择第一个非空（`NOT NULL`）的唯一列作为聚簇索引的索引键。
        3. 如果以上两者都没有，InnoDB 将自动生成一个隐式的、不可见的自增 ID 列作为聚簇索引的索引键。
- **辅助索引（Secondary Index）**：
    
    - **定义**：辅助索引的叶子节点存放的是**主键值**，而不是完整的行数据。它也被称为二级索引或非聚簇索引。
        
    - **查询过程（回表）**：当使用辅助索引查询时，首先会在辅助索引的 B+Tree 中根据索引值找到对应的主键值，然后再利用这个主键值去聚簇索引的 B+Tree 中查找完整的行数据。这个**需要查找两个 B+Tree** 的过程被称为“回表”。
        
    - **覆盖索引（Covering Index）**：当查询所需的所有数据都可以在辅助索引的叶子节点中找到，而**无需回表**去聚簇索引中查询时，这种情况被称为“覆盖索引”。这大大提高了查询效率。
        

#### **2. B+Tree 的核心特点**

B+Tree 是一种多叉树，它的结构和查询效率都针对磁盘 I/O 进行了优化：

- **非叶子节点只存储索引**：非叶子节点不存储具体数据，只存储索引值，这使得单个节点可以存储更多的索引，从而降低树的高度。
    
- **叶子节点存储数据**：所有的数据都存放在叶子节点中。
    
- **有序性**：节点中的数据（索引和数据）都是按键值顺序存放的。
    
- **双向链表**：所有叶子节点都通过双向链表连接起来，这使得范围查询和顺序遍历变得非常高效。
    

#### **3. B+Tree 索引的查询过程**

**通过主键查询：**
![[Pasted image 20250923134915.png]]
当执行 `SELECT * FROM product WHERE id = 5;` 这类主键查询时，B+Tree 的查找过程为：

1. 从根节点开始，与节点中的索引值进行比较，确定搜索路径。
    
2. 逐层向下，直到到达叶子节点。
    
3. 在叶子节点中找到匹配的索引值，直接获取完整的行数据。
    

由于 B+Tree 的高度通常只有 3-4 层，因此查询千万级别的数据也只需要 3-4 次磁盘 I/O，效率极高。

**通过二级索引查询：**
![[Pasted image 20250923134910.png]]
当执行 `SELECT * FROM product WHERE product_no = '0002';` 这类二级索引查询时，查询过程包括“回表”：

1. 在 `product_no` 二级索引的 B+Tree 中查找，找到 `product_no = '0002'` 对应的**主键值**。
    
2. 拿着这个主键值，再次去**聚簇索引**的 B+Tree 中查找。
    
3. 在聚簇索引的叶子节点中找到该主键值对应的**完整行数据**。
    ![[Pasted image 20250923134948.png]]

### **三、B+Tree 索引的优势分析**

#### **1. B+Tree vs B Tree**

- **查询效率**：B+Tree 的非叶子节点不存储数据，因此单个节点可以存储更多索引，从而降低了树的高度。在相同数据量下，B+Tree 的磁盘 I/O 次数更少。
    
- **范围查询**：B+Tree 的叶子节点通过双向链表连接，非常适合进行范围查询和顺序遍历，而 B Tree 无法高效地进行范围查询。
    

#### **2. B+Tree vs 二叉树**

- **树高**：二叉树的搜索复杂度是 `O(logN)`，在数据量大时树高会很高，导致更多的磁盘 I/O。而 B+Tree 的分支数（`d`）很大，其搜索复杂度为 `O(logdN)`，树高很低，大大减少了磁盘 I/O 次数。
    

#### **3. B+Tree vs Hash**

- **适用场景**：Hash 索引在做**等值查询**时效率极高（`O(1)`），但它**不适合做范围查询**，因为哈希值是无序的。而 B+Tree 既支持等值查询，又支持范围查询，适用场景更广。

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

#### [#](https://xiaolincoding.com/mysql/index/index_interview.html#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95)唯一索引
建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。
#### 前缀索引
前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。
使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。
```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```

### **什么是联合索引？**

**联合索引（Composite Index）** 也称为复合索引，它通过将多个字段组合在一起创建一个索引。

例如，为 `product` 表的 `product_no` 和 `name` 字段创建联合索引：

```SQL
CREATE INDEX index_product_no_name ON product(product_no, name);
```

### **二、联合索引的 B+Tree 结构与排序**

联合索引的 B+Tree 与单列索引类似，但其非叶子节点和叶子节点的 **key 值是多个字段的组合**。

联合索引 (`product_no`, `name`) 的 B+Tree 结构具有以下特点：

- **先按第一个字段排序**：整个索引的排序是先按照 `product_no` 字段的值进行全局排序。
    
- **再按第二个字段排序**：当 `product_no` 的值相同时，再按照 `name` 字段的值进行局部排序。

正是基于这种排序特性，引出了联合索引的**最左匹配原则**。

### **三、最左匹配原则（Leftmost Prefix Matching）**

**定义**：在使用联合索引进行查询时，MySQL 会按照最左优先的方式进行索引匹配。查询条件必须从索引的最左侧字段开始，才能有效利用联合索引。
- **有效匹配示例**：对于联合索引 `(a, b, c)`，以下查询条件可以命中索引：
    
    - `where a = 1`
    - `where a = 1 and b = 2`
    - `where a = 1 and b = 2 and c = 3`
    - `where a = 1 and c = 3` （虽然 `b` 字段未在条件中，但 `a` 字段满足最左匹配，仍然可以使用索引）
        
    > **注意**：`where` 子句中字段的顺序不影响查询，因为查询优化器会自动调整顺序。例如 `where b=2 and a=1` 同样能命中索引。
    
- **索引失效示例**：以下查询条件因为不符合最左匹配原则，会导致联合索引失效：
    - `where b = 2`
    - `where c = 3`
    - `where b = 2 and c = 3`
    
    **原因**：因为索引的排序是先按 `a`，再按 `b`，`b` 和 `c` 在全局上是无序的。如果没有 `a` 字段作为起点进行匹配，B+Tree 无法进行有序查找。
    

---

### **联合索引中的范围查询**

联合索引的最左匹配原则在遇到**范围查询**时会表现出特殊行为。具体是“停止匹配”还是“不停止匹配”，取决于范围查询的类型。

#### **1. 会“停止匹配”的范围查询**

当遇到 **`>`** 或 **`<`** 这类范围查询时，联合索引的匹配会停止。该范围查询字段可以使用索引，但其后的字段将无法使用索引。
- **示例**：`SELECT * FROM t_table WHERE a > 1 AND b = 2`，对于联合索引 `(a, b)`：
    - `a` 字段使用了索引。
    - `b` 字段没有使用索引，因为它在 `a` 字段的范围之后，其值是无序的。
    - 在执行计划中，`key_len` 只会显示 `a` 字段的长度，表明只有 `a` 字段的查询条件被用于索引扫描。

#### **2. 不会“停止匹配”的范围查询**

对于 **`>=`、`<=`、`BETWEEN`、`LIKE '前缀%'`** 这类范围查询，联合索引的匹配**并不会停止**，其后的字段依然可以使用索引。

- **示例1**：`SELECT * FROM t_table WHERE a >= 1 AND b = 2`，对于联合索引 `(a, b)`：
    
    - **`a` 字段**首先进行范围匹配，找到所有 `a >= 1` 的记录。
        
    - 对于 `a` 值相同的记录（例如 `a=1`），其后的 `b` 字段是有序的。
        
    - **`b` 字段**可以继续利用索引进行精确匹配，从而进一步缩小扫描范围。
        
    - 在执行计划中，`key_len` 会同时包含 `a` 和 `b` 的长度，说明两个字段都用到了索引。
1. **精确查找起始点**：MySQL 会在索引树中找到满足 `a = 1` 且 `b = 2` 的第一条记录。这个点可以被视为扫描的**精确起点**。
2. **向后扫描**：从这个起点开始，MySQL 沿着叶子节点的双向链表向后扫描。
3. **停止点**：这个扫描过程理论上会一直进行，直到没有更多的记录。但由于您的查询条件是 `a >= 1`，它会扫描所有 `a >= 1` 的记录。
`WHERE a >= 1 AND b = 2`：

- **扫描的起始边界**：优化器可以非常精确地确定，扫描要从 `(1, 2)` 这条记录开始。这个起点同时利用了 `a` 和 `b` 的条件。
- **扫描的结束边界**：尽管 `a >= 1` 是一个开放式范围，没有一个明确的上限，但因为 `b = 2` 在 `a=1` 的等值部分被有效利用了，优化器认为这是一个可以利用索引优势的查询。
`key_len` 告诉我们的是，优化器**有能力**利用 `a` 和 `b` 这两个字段来定义扫描的**起始点**，因此将两个字段都计入。

这里需要注意的是，当扫描到 `a = 2` 的记录时，MySQL 无法继续利用 `b = 2` 来进行精确查找，因为在 `a` 值变化后，`b` 的全局有序性已经被打破了。
**所以，更准确地说，联合索引的匹配在遇到 `a >= 1` 这种范围查询后，只在 `a` 字段的等值部分 (`a=1`) 上继续使用 `b` 字段进行精确查找，而在 `a` 字段的范围部分 (`a>1`)，`b` 字段的条件就退化成一个过滤条件了。**
用 `key_len` 可以很好地证明这一点：
- 当您查询 `WHERE a=1 AND b=2` 时，`key_len` 包含了 `a` 和 `b` 的长度，因为它们都参与了索引的**精确查找**。
- 当您查询 `WHERE a > 1 AND b = 2` 时，`key_len` **只**包含 `a` 的长度，因为 `b` 没有参与索引查找，只被用于过滤。
-**扫描的起始边界**：优化器只能确定扫描要从 `a=2` 开始，而无法利用 `b=2` 来精确定位到 `(2, 2)`。因为它无法保证 `a=2` 时 `b=2` 的记录是第一条。
- **扫描的结束边界**：没有明确的上限。
由于 `a > 1` 这种纯粹的开放式范围，让 `b` 字段在起始点的定位上无能为力，所以 `key_len` 就只会显示 `a` 的长度。
![[Pasted image 20250923140916.png]]
- **示例2**：`SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，对于联合索引 `(a, b)`：
    
    - 在 MySQL 中，`BETWEEN` 等同于 `a >= 2 AND a <= 8`。
        
    - 这与 `a >= 1` 的情况类似，在 `a` 值相同的记录内部，`b` 字段有序。
        
    - 因此，**`a` 和 `b` 字段**都用到了联合索引，`key_len` 会同时包含两者长度。
优化器在生成执行计划时，会确定两个边界条件：
- **扫描起始点 (Start Key)**: `(a, b)` 的值是 `(2, 2)`
- **扫描结束点 (End Key)**: `(a, b)` 的值是 `(8, 2)`
也就是说，优化器通过 `a` 和 `b` 的条件，将索引扫描的范围精确地锁定在了 `(2, 2)` 到 `(8, 2)` 之间。`key_len` 所反映的，就是优化器在生成这两个边界条件时，**使用了多少个索引字段**。由于它使用了 `a` 和 `b` 两个字段来确定起始和结束边界，所以 `key_len` 会显示为两个字段的长度之和。

- **示例3**：`SELECT * FROM t_user WHERE name LIKE 'j%' AND age = 22`，对于联合索引 `(name, age)`：
    
    - **`name` 字段**首先进行前缀匹配，扫描所有以 `'j'` 开头的记录。
        
    - 在 `name` 值相同的记录内部，`age` 字段是有序的。
        
    - **`age` 字段**可以继续利用索引进行 `age = 22` 的精确匹配。
        
    - 在执行计划中，`key_len` 会同时包含 `name` 和 `age` 的长度，证明都用到了索引。
- name 字段的类型是 varchar(30) 且不为 NULL，数据库表使用了 utf8mb4 字符集，一个字符集为 utf8mb4 的字符是 4 个字节，因此 name 字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为 name 是变长类型的字段，需要再加 2 字节（用于存储该字段实际数据的长度值），也就是 name 的 key_len 为 122。
- age 字段的类型是 int 且不为 NULL，key_len 为 4。
![[Pasted image 20250923141756.png]]
> **关于 `key_len` 的特殊性**：`key_len` 表示优化器用于形成扫描区间边界条件的索引字段长度。对于变长字段，`key_len` 会特殊地多显示 2 个字节，但这不影响我们判断哪些字段被索引利用了。

---

### **五、索引下推（Index Condition Pushdown）

**问题背景**：对于联合索引 `(a, b)`，当执行 `SELECT * FROM table WHERE a > 1 AND b = 2` 时，`a` 字段能够利用索引进行范围扫描，但 `b` 字段无法利用索引的有序性进行查找。在没有索引下推的情况下，MySQL 会先在索引树中找到所有 `a > 1` 的记录的主键 ID，然后逐一**回表**（通过主键索引查找完整行数据），再在完整数据行上判断 `b` 是否等于 2。

当使用联合索引时，MySQL 在查询过程中会利用 **索引下推** 这项优化技术。它在 **索引内部** 就对数据进行过滤，减少了不必要的回表次数，从而大幅提高了查询效率。
- **优化原理**：MySQL 5.6 引入了索引下推优化。它允许在**联合索引遍历过程中**，直接对索引中包含的字段（即 `b`）进行条件判断。
- **工作流程**：
    1. MySQL 在联合索引 `(a, b)` 的 B+Tree 上找到所有 `a > 1` 的记录。
    2. 在找到主键 ID 后，**不立即回表**，而是先检查该记录的 `b` 字段是否满足 `b = 2` 的条件。
    3. 如果满足，才进行回表操作。如果不满足，则直接跳过，不再回表。
- **效果**：通过在索引层面过滤掉不符合条件的记录，减少了大量的回表次数，显著提升了查询性能。
- **判断依据**：当查询语句的 `EXPLAIN` 计划中的 `Extra` 列出现 `Using index condition` 时，就表示使用了索引下推优化。

### 索引优化
#### **1. 联合索引的字段顺序**

- **原则**：将**区分度大**的字段放在联合索引的前面。
- **区分度计算**：`区分度 = 字段不同值的个数 / 表的总行数`。
- **原因**：高区分度的字段能够更快地缩小查询范围。如果将区分度很小的字段（如性别）放在前面，即便使用了索引，也可能导致扫描大量数据，从而让优化器选择放弃索引而进行全表扫描。
 MySQL 有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是"30%"）很高的时候，它一般会忽略索引，进行全表扫描。
#### **2. 利用联合索引进行排序优化**

- **问题**：`SELECT * FROM order WHERE status = 1 ORDER BY create_time ASC`
    
- **优化方式**：为 `status` 和 `create_time` 建立联合索引 `(status, create_time)`。
    
- **原因**：
    
    - 如果只对 `status` 建立索引，虽然能够快速筛选出 `status = 1` 的记录，但还需要对这些记录进行额外的**文件排序（filesort）**，这会增加额外的性能开销。
        
    - 如果建立 `(status, create_time)` 联合索引，由于索引本身就是按 `status` 排序后，再按 `create_time` 排序的，因此筛选出的数据天然就是有序的，从而避免了文件排序，提高了查询效率。
### **索引的创建与使用场景**

#### **1. 何时需要创建索引？**

- **字段有唯一性限制**：如商品编码、身份证号等，可以确保数据的唯一性，并用于快速查询。
    
- **作为 `WHERE` 查询条件**：这是索引最常见的用途，可以快速定位数据。
    
- **作为 `GROUP BY` 和 `ORDER BY` 字段**：可以利用索引的有序性，避免额外的排序或分组操作，减少文件排序（Using filesort）。
    

#### **2. 何时不需要创建索引？**

- **不作为查询条件**：如果字段不常用于 `WHERE`、`GROUP BY`、`ORDER BY`，则没有创建索引的必要，因为索引会占用空间并影响增删改效率。
    
- **字段存在大量重复数据**：如性别字段，区分度极低。在这些情况下，优化器可能直接选择全表扫描，索引反而成为负担。
    
- **表数据量太少**：索引的优势在于处理大量数据，对于小表来说，全表扫描可能更快。
    
- **经常更新的字段**：频繁修改索引字段会增加维护成本，因为每次修改都需要重新维护 B+Tree 的有序性，从而影响数据库性能。

### **四、常见的索引优化方法**

- **前缀索引**：
    
    - **原理**：对字符串的前几个字符建立索引。
    - **优点**：减小索引字段大小，节省空间，提高查询效率。
    - **局限性**：无法用于 `ORDER BY`，也无法用作覆盖索引。
        
- **覆盖索引**：
    
    - **原理**：查询的所有字段都可以在索引的 B+Tree 叶子节点中找到，从而**无需回表**查询主键索引。
    - **优点**：大大减少了 I/O 操作，显著提升性能。例如，查询商品名称和价格，可以建立 `(商品ID, 名称, 价格)` 联合索引来避免回表。
        
- **主键索引最好是自增的**：
    
    - **原因**：自增主键保证了新数据总是追加到索引的末尾，避免了因随机插入而导致的数据页分裂，提高了插入效率，并减少了内存碎片。
    - **最佳实践**：主键字段的长度也应尽量小，因为二级索引的叶子节点会存放主键值，主键越小，二级索引占用的空间也越小。
        
- **索引列最好设置为 `NOT NULL`**：
    
    - **原因**：`NULL` 值会使索引统计和值比较变得复杂，影响优化器的选择；同时 `NULL` 值会占用额外的存储空间。
### 防止索引失效

#### **常见的索引失效场景**

为了避免写出低效的查询语句，我们需要了解常见的索引失效情况
- **模糊匹配**：当使用**左模糊匹配**（`LIKE '%xx'`）或**左右模糊匹配**（`LIKE '%xx%'`）时，索引会失效。
- **计算、函数或类型转换**：如果在查询条件中对索引列进行了**计算**、使用了**函数**，或者进行了**类型转换**，都会导致索引失效。
- **不遵循最左匹配原则**：对于联合索引，查询条件必须从最左边的字段开始匹配，否则索引会失效。
- **`OR` 条件**：如果在 `WHERE` 子句中，`OR` 前的条件列是索引列，而 `OR` 后的条件列不是索引列，那么整个索引将失效。

我上面说的是常见的索引失效场景，实际过程中，可能会出现其他的索引失效场景，这时我们就需要查看执行计划，通过执行计划显示的数据判断查询语句是否使用了索引。

如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。

![](https://cdn.xiaolincoding.com//mysql/other/798ab1331d1d6dff026e262e788f1a28.png)

对于执行计划，参数有：

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型，我们需要重点看这个。

type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）这是最差的类型，意味着 MySQL 遍历了整个表来找到匹配的行。应尽量避免。
- index（全索引扫描）；虽然比 `ALL` 好，但开销依然很大，因为它需要遍历整个索引树。
- range（索引范围扫描）；通常出现在 `WHERE` 子句中使用 `>、<、IN、BETWEEN` 等关键词时。效率比全表/全索引扫描高得多。
- ref（非唯一索引扫描）；可能返回多条记录，但扫描范围小。
- eq_ref（唯一索引扫描）；通常用于多表连接，关联字段是唯一索引。
- const（结果只有一条的主键或唯一索引扫描）。通过主键或唯一索引与常量值进行比较，效率最高。


需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，**const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中**。

> 除了关注 type，我们也要关注 extra 显示的结果。

`EXPLAIN` 的 `Extra` 列提供了一些重要的补充信息，需要特别关注：

- `Using filesort`：当查询语句需要排序但无法利用索引时，MySQL 将使用外部文件进行排序，效率很低。应尽量通过创建联合索引来避免。
- `Using temporary`：表示使用了临时表来保存中间结果，通常发生在复杂的 `GROUP BY` 或 `ORDER BY` 中，效率较低。应尽量避免。
- `Using index`：表示**覆盖索引**，即查询所需的所有数据都可以在索引中找到，无需回表查询，效率非常高。

## [#](https://xiaolincoding.com/mysql/index/index_interview.html#%E6%80%BB%E7%BB%93)总结
![[Pasted image 20250923142445.png]]