### 表空间文件的结构是怎么样的？

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB存储引擎的逻辑存储结构大致如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png)

下面我们从下往上一个个看看。

#### [#](https://xiaolincoding.com/mysql/base/row_format.html#_1%E3%80%81%E8%A1%8C-row)1、行（row）

- **定义：** 数据库中的每一条记录都以行的形式存储，每一行记录的存储结构会根据不同的行格式而有所不同。
    
- **注意：** 行是存储数据的最小单位。

#### [#](https://xiaolincoding.com/mysql/base/row_format.html#_2%E3%80%81%E9%A1%B5-page)2、页（page）

- **定义：** 页是 **InnoDB** 读写磁盘的最小单位。
    
- **为什么需要页？** 如果数据库以行为单位进行读写，每次 I/O 只能处理一条记录，效率会非常低。将多条记录打包成一个 **页**，可以一次性读写多条数据，大大提高效率。
    
- **大小：** 默认情况下，一个页的大小为 **16KB**。
    
- **存储：** 表中的行记录都存放在 **数据页** 中。除了数据页，还有 **Undo 日志页**、**溢出页** 等多种类型的页。

#### [#](https://xiaolincoding.com/mysql/base/row_format.html#_3%E3%80%81%E5%8C%BA-extent)3、区（extent）

- **定义：** 区是由 **64** 个连续的页（共 **1MB**）组成的。
    
- **为什么需要区？** **InnoDB** 的数据是以 **B+ 树** 的形式组织的。如果每次都以页为单位来分配空间，相邻的页在物理上可能相隔很远，导致范围查询时需要进行大量的 **随机 I/O**，性能很差。
    
- **作用：** 将多个页打包成 **区**，可以确保它们在物理上是连续的，从而将随机 I/O 转化为效率更高的 **顺序 I/O**，极大地提升了查询性能。

#### [#](https://xiaolincoding.com/mysql/base/row_format.html#_4%E3%80%81%E6%AE%B5-segment)4、段（segment）

- **定义：** 段由多个区组成，它们都是为了管理一类数据而存在的。
- **分类：** 段主要分为以下几种：
    - **数据段：** 存放 **B+ 树** **叶子节点** 的所有区。叶子节点包含了实际的行记录数据。
    - **索引段：** 存放 **B+ 树** **非叶子节点** 的所有区。非叶子节点是索引，不包含实际数据。
    - **回滚段：** 存放回滚日志（**Undo log**）的区。**MVCC**（多版本并发控制）就是利用回滚段来实现多版本查询的。
好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。
## InnoDB 行格式有哪些？

**行格式（Row Format）** 描述了一条数据库记录在磁盘上的存储结构。InnoDB 存储引擎提供了四种行格式：

- **Redundant：** MySQL 5.0 版本之前的古老格式，已经很少使用。
- **Compact：** MySQL 5.1 之后默认的紧凑格式，旨在节省空间。
- **Dynamic 和 Compressed：** MySQL 5.7 之后默认使用 **Dynamic**。它们都是在 Compact 格式基础上进行的优化。

本笔记将重点介绍 **Compact** 格式，因为它构成了 Dynamic 和 Compressed 的基础。

## [#](https://xiaolincoding.com/mysql/base/row_format.html#compact-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7)COMPACT 行格式长什么样？
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

接下里，分别详细说下。

### [#](https://xiaolincoding.com/mysql/base/row_format.html#%E8%AE%B0%E5%BD%95%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF)记录的额外信息

记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。

#### [#](https://xiaolincoding.com/mysql/base/row_format.html#_1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8)1. 变长字段长度列表

- **作用：** 存储变长字段（如 `VARCHAR`、`TEXT`、`BLOB`）的实际数据长度。
- **存储顺序：** 变长字段的长度值是 **逆序存放** 的。
    - **例子：** 如果 `name` 的长度是 1 字节，`phone` 的长度是 3 字节，那么存储的顺序会是 `[03 01]`，而不是 `[01 03]`。
    - **设计原因：** 这样的设计可以提高 **CPU Cache 的命中率**，因为可以使字段长度信息和其对应的数据在物理上更接近，便于 CPU 一次性读取。
- **存在条件：** 只有当表中存在变长字段时，才会包含这个列表。如果所有字段都是定长的（如 `INT`、`CHAR`），则不会有这个列表，以节省空间。

#### [#](https://xiaolincoding.com/mysql/base/row_format.html#_2-null-%E5%80%BC%E5%88%97%E8%A1%A8)2. NULL 值列表

**作用：** 用一个二进制位来标记该行中哪些列的值为 `NULL`，以节省存储空间。

- `1` 代表该列的值为 `NULL`。
    
- `0` 代表该列的值不为 `NULL`。

- **存储规则：**
    - 列表中的二进制位也是 **逆序排列** 的，与变长字段长度列表的设计理念相同。
    - 列表必须占用 **整数个字节**。如果列数不足 8 的倍数，高位会用 `0` 补齐。
    - **例子：** 一张表有 3 个列允许为 `NULL`。如果第二列为 `NULL`，那么列表为 `[010]`，不足 8 位，补齐后为 `[00000010]`（十六进制为 `0x02`）。
- **存在条件：** 只有当表中存在允许 `NULL` 值的字段时，才会包含这个列表。为了节省空间，通常建议将字段设置为 `NOT NULL`。
- **空间大小：** 列表的空间不是固定的 1 字节，它会根据允许 `NULL` 值的列数动态调整。例如，如果有 9 个允许 `NULL` 的列，则需要 2 字节来存储这个列表。

#### **3. 记录头信息**

- **作用：** 记录了行的各种状态信息，是固定占用 **5 字节** 的。
    
- **部分重要信息：**
    
	- **delete_flag**：表示该行是否被删除。
	- **min_rec_flag**：表示是否是B+树非叶子节点中的最小记录。
	- **n_owned**：表示在当前页中该行记录拥有的记录数。
	- **heap_no**：表示当前记录在页中的相对位置（从0开始）。
	- **record_type**：表示当前记录的类型，例如0表示普通记录，1表示B+树的非叶子节点记录，2表示Infimum记录，3表示Supremum记录。
	- **next_record**：这是一个指向下一条记录的指针，正是通过这个指针，页中的所有行记录可以被组织成一个单向链表。
###   记录的真实数据

记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png)

#### **1. row_id**

- **作用：** 行记录的唯一标识。
- **是否必须：** **非必需**。
    - 当我们创建表时定义了 **主键** (`PRIMARY KEY`) 或 **唯一非空** (`UNIQUE NOT NULL`) 约束时，**InnoDB** 会使用这些字段作为主键来唯一标识一行记录。在这种情况下，`row_id` 字段不会存在。
    - 如果既没有主键，也没有唯一的非空字段，**InnoDB** 才会自动为每一行记录生成一个 `row_id` 隐藏字段。
- **大小：** 占用 **6 字节**。

#### **2. trx_id**

- **作用：** 记录了 **生成或修改该行记录的事务ID**。
- **是否必须：** **必需**。
- **大小：** 占用 **6 字节**。
- **应用：** 这个字段是 **MVCC**（多版本并发控制）机制实现的基础之一。通过 `trx_id`，**InnoDB** 可以追踪到某条记录是由哪个事务创建的，从而判断当前事务是否可见该版本的数据。
#### **3. roll_pointer**

- **作用：** 一个 **回滚指针**，指向该行记录的 **上一个版本**。
- **是否必须：** **必需**。
- **大小：** 占用 **7 字节**。
- **应用：** 这个指针同样是 **MVCC** 的核心。它将不同版本的同一行记录连接成一个 **版本链**。当需要查询一个老版本的数据时，`InnoDB` 会沿着 `roll_pointer` 指针找到之前版本的数据。这些旧版本的数据都存放在 **回滚段** 中。
    
这三个隐藏字段，特别是 `trx_id` 和 `roll_pointer`，是理解 **MVCC** 机制的关键。它们共同构成了 **InnoDB** 实现事务隔离和多版本并发的基础。

### **`varchar(n)` 的最大取值**
要理解 `varchar(n)` 中 `n` 的最大值，首先要明白一个前提：**MySQL InnoDB 对一行记录的总长度有限制**。
- **一行记录最大长度：** MySQL 规定，除了 `TEXT`、`BLOB` 等大对象类型之外，**一行所有列（不包括隐藏字段和记录头信息）的长度总和不能超过 65535 个字节**。
- **注意：** 这个 65535 个字节是**一行所有列的总长度**，而不是单列的限制。并且，它还包含了额外的存储开销（`storage overhead`）。

### **单字段情况下的最大值计算**

当表中只有一个 `varchar(n)` 类型的字段时，`n` 的最大值并不是 65535，因为我们必须考虑 `storage overhead` 所占用的字节数。这个开销主要来自于 **`变长字段长度列表`** 和 **`NULL 值列表`**。

#### **计算公式**

`varchar(n) 的最大字节数 = 65535 - (变长字段长度列表占用的字节数) - (NULL 值列表占用的字节数)`

#### **1. `NULL` 值列表占用的字节数**

- 如果字段允许为 `NULL`，则需要 1 字节来存储 `NULL` 值列表。
#### **2. `变长字段长度列表`占用的字节数**

- 这个列表用来存储变长字段（如 `VARCHAR`）的实际数据长度。它占用的字节数取决于该字段的最大允许存储字节数。 注意是**字节数**
- **1 字节：** 当变长字段允许存储的最大字节数 **小于等于 255 字节**时，需要用 1 字节来表示其长度。
- **2 字节：** 当变长字段允许存储的最大字节数 **大于 255 字节**时，需要用 2 字节来表示其长度。

#### **案例分析：`VARCHAR(n)` 且字符集为 `ascii`**

- **`ascii` 字符集：** 一个字符占用 1 字节。
- **允许 `NULL`：** `NULL` 值列表占用 **1 字节**。
- **计算 `n` 的最大值：**
    - 因为 `n` 必然大于 255，所以 `变长字段长度列表` 占用 **2 字节**。
    - `n` 的最大取值 = `65535 - 2（变长字段长度）- 1（NULL 值列表）` = `65532`。
    - 所以，在 `ascii` 字符集下，`VARCHAR(65532)` 是可以成功创建的。
#### **案例分析：`VARCHAR(n)` 且字符集为 `UTF-8`**

- **`UTF-8` 字符集：** 一个字符最多占用 3 个字节。
    
- **计算 `n` 的最大值：**
    - 最大字节数是 `65532`。
    - `n` 的最大取值 = `65532 / 3` = `21844`。
    - 所以，在 `UTF-8` 字符集下，`VARCHAR(21844)` 是可以成功创建的。
### **多字段情况下的最大值**

当表中存在多个字段时，计算会更复杂，但基本原理不变。你只需要保证 **所有字段的长度总和 + `变长字段长度列表` + `NULL` 值列表所占用的字节数** 不超过 65535 字节。
- **所有字段的长度总和：** 包括定长字段（如 `INT`、`CHAR`）的固定长度，以及变长字段（如 `VARCHAR`）的最大允许长度。
- **变长字段长度列表：** 列表中会记录所有变长字段的长度信息。如果所有变长字段的最大长度之和超过 255 字节，那么该列表可能需要更多字节来存储长度信息。
总的来说，`varchar(n)` 的 `n` 值并非随意取，它受到 **InnoDB 一行记录总长度**、**字符集** 和 **字段是否允许为 NULL** 等多种因素的共同制约。
## 行溢出后，MySQL 是怎么处理的？

### **什么是行溢出？**

MySQL 的 **InnoDB** 存储引擎以 **页（Page）** 为单位进行磁盘读写，默认大小为 **16KB**。然而，像 `VARCHAR`、`TEXT` 或 `BLOB` 这样的变长字段，其数据量可能远超 16KB，导致无法在单个数据页中完整存储一条记录。当这种情况发生时，就产生了 **行溢出**。

---

### **不同行格式下的行溢出处理**

MySQL 主要通过将溢出的数据存储到额外的 **溢出页（Overflow Page）** 中来解决行溢出问题。不同行格式对此的处理方式略有不同。

#### **1. Compact 行格式**

- **处理方式：** 采用 **部分数据+指针** 的方式。
    
- **具体做法：** 当一个大字段发生行溢出时，**Compact** 格式会在数据页的真实数据处保留该列的一部分数据（通常是前 768 字节），然后将剩余的数据存储到单独的 **溢出页** 中。
    
- **指针：** 在真实数据处，会用一个 **20 字节** 的指针来指向溢出页的地址，通过这个地址可以找到剩余的数据。
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png)
#### **2. Dynamic 和 Compressed 行格式**

- **处理方式：** 采用 **完全溢出** 的方式。
    
- **具体做法：** 这两种格式与 **Compact** 不同，它们不会在数据页中保留任何溢出列的数据片段。
    
- **指针：** 真实数据处只存储一个 **20 字节** 的指针，该指针直接指向存储在 **溢出页** 中的完整数据。
    
- **优点：** 这种方式使得数据页中的记录更加紧凑，避免了因大字段的前 768 字节而导致的数据页碎片化，从而提高了存储效率。这也是 MySQL 5.7 之后默认使用 **Dynamic** 行格式的原因之一。
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png)

## [#](https://xiaolincoding.com/mysql/base/row_format.html#%E6%80%BB%E7%BB%93)总结

#### **1. MySQL 的 `NULL` 值是怎么存放的？**

- **存储方式：** 在 **Compact** 行格式中，`NULL` 值并不会占用真实数据空间。它会使用一个单独的 **`NULL` 值列表**来标记哪些列的值是 `NULL`。
    
- **空间开销：** 这个列表至少占用 **1 字节**。如果你将所有字段都定义为 `NOT NULL`，就可以节省这部分空间。
#### **2. MySQL 怎么知道 `varchar(n)` 实际占用的数据大小？**

- **存储方式：** **Compact** 行格式使用一个 **`变长字段长度列表`** 来存储每个变长字段实际占用的字节数。
- **位置：** 这个列表位于行记录的开头，在真实数据之前。
    

#### **3. `varchar(n)` 中 `n` 的最大取值是多少？**

- **核心原则：** 一行记录（不包括大对象字段）的总长度不能超过 **65535 字节**。这个总长度包含了 **`变长字段长度列表`** 和 **`NULL` 值列表** 的开销。
- **单字段情况：** 如果表中只有一个允许为 `NULL` 的 `VARCHAR` 字段，且使用 `ascii` 字符集，那么 `n` 的最大值为 **65532**。
    - 计算公式：`65535（总限制）- 2（变长字段长度开销）- 1（NULL 值列表开销）= 65532`。
- **多字段情况：** 所有字段的长度总和，加上所有额外开销（如变长字段列表和 `NULL` 值列表），必须小于等于 **65535**。
#### **4. 行溢出后，MySQL 是怎么处理的？**

- **触发条件：** 当一条记录的所有字段无法在单个数据页（通常为 16KB）中存储时，就会发生行溢出。
- **Compact 行格式：**
    - 它会在数据页中保留该列的 **一部分数据**。
    - 剩余数据会被存储在独立的 **溢出页** 中。
    - 在数据页中会用一个 **20 字节** 的指针来指向溢出页的地址。
- **Compressed 和 Dynamic 行格式：**
    - 这两种格式采取 **完全溢出** 的方式。
    - 数据页中 **不存储任何溢出数据**，只保存一个 **20 字节** 的指针。
    - 完整的数据都存储在溢出页中。