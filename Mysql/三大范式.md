### **简要回答**

数据库的三大范式（1NF、2NF、3NF）是为了减少数据冗余和避免异常操作而设计的规范。它们分别是：

1. **第一范式（1NF）**：要求数据表中的每个字段只能包含原子值。
2. **第二范式（2NF）**：要求满足 1NF，并且所有非主属性完全依赖于主键。
3. **第三范式（3NF）**：要求满足 2NF，并且每个非主属性直接依赖于主键，而不通过其他非主属性间接依赖。

### 数据库范式的目的

**范式（Normal Form）**是数据库设计的一套理论准则，其核心目标是：

- **减少数据冗余（Redundancy）**：避免同一数据在多个地方重复存储。
    
- **消除更新异常（Update Anomalies）**：解决在更新、插入或删除数据时可能产生的一致性问题。
简单来说，范式就是让你的数据库结构更合理，数据更干净。

### 第一范式 (1NF)

**第一范式**要求数据库表的每一列都是**不可再分的原子值**。

- **问题所在**：当一列数据可以被分解成多个有意义的部分时，就违反了1NF。例如，一个“地址”列包含“省份”、“城市”和“街道”等信息，或者一个“电话号码”列存储了多个号码。
    
- **如何解决**：将不可分割的数据拆分成独立的列。
**例子：**
一个未满足1NF的表

|员工ID|姓名|电话号码|
|---|---|---|
|1|张三|138-1234-5678, 139-8765-4321|

拆分成符合1NF的表：

|员工ID|姓名|电话号码1|电话号码2|
|---|---|---|---|
|1|张三|138-1234-5678|139-8765-4321|

**注意：** 上面这个例子虽然满足了1NF，但它带来了新的问题——列数不确定。更好的方式是再建一个单独的“电话”表，这就是第二范式要解决的问题。

### 第二范式 (2NF)

**第二范式**要求在满足1NF的基础上，非主键列**必须完全依赖于主键**。换句话说，表中的每一列都必须由整个主键决定。

- **问题所在**：当一个表的主键是**复合主键**（由多个列组成）时，如果某些非主键列只依赖于主键的一部分，就违反了2NF。这会导致数据冗余和更新异常。
    
- **如何解决**：将只依赖于部分主键的列拆分到新的表中。

**例子：**

一个未满足2NF的表（订单表，主键为`{订单ID, 产品ID}`）：

|订单ID|产品ID|产品名称|订单金额|
|---|---|---|---|
|1001|A01|笔记本电脑|5000|
|1001|B02|鼠标|50|
|1002|A01|笔记本电脑|5000|


- **问题**：这里的`产品名称`只依赖于`产品ID`，而不依赖于完整的复合主键`{订单ID, 产品ID}`。`笔记本电脑`这个信息被重复存储了两次，这就是数据冗余。如果`笔记本电脑`需要更新名称，你必须更新多条记录。
- **解决方法**：拆分成两个表。

拆分成符合2NF的表：

**订单表：**

|订单ID|产品ID|订单金额|
|---|---|---|
|1001|A01|5000|
|1001|B02|50|
|1002|A01|5000|

**产品表：**

|产品ID|产品名称|
|---|---|
|A01|笔记本电脑|
|B02|鼠标|
### 第三范式 (3NF)

**第三范式**要求在满足2NF的基础上，**非主键列之间不存在传递依赖**。也就是说，非主键列不能依赖于另一个非主键列。

- **问题所在**：当一个非主键列可以由另一个非主键列推导出来时，就违反了3NF。这同样会导致数据冗余和更新异常。
    
- **如何解决**：将传递依赖的列拆分到新的表中。
**例子：**
一个未满足3NF的表（员工表，主键为`员工ID`）：

|员工ID|姓名|部门ID|部门名称|
|---|---|---|---|
|101|张三|D01|技术部|
|102|李四|D02|财务部|
|103|王五|D01|技术部|


- **问题**：这里的`部门名称`依赖于`部门ID`，而`部门ID`是一个非主键列。这种“传递依赖”（`员工ID` -> `部门ID` -> `部门名称`）导致`技术部`这个信息被重复存储。如果`技术部`的名称需要更新，同样需要更新多条记录。
    
- **解决方法**：拆分成两个表。

拆分成符合3NF的表：

**员工表：**

|员工ID|姓名|部门ID|
|---|---|---|
|101|张三|D01|
|102|李四|D02|
|103|王五|D01|


**部门表：**

|部门ID|部门名称|
|---|---|
|D01|技术部|
|D02|财务部|
