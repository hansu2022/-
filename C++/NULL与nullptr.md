### **C++ 中的 `nullptr` 与 `NULL`**

`NULL` 是 C 语言的遗留产物，而 `nullptr` 是 C++11 引入的，旨在解决 `NULL` 在类型安全方面的问题。
#### **1. 类型上的根本区别**

- **`NULL`**：
    - **本质**：一个宏定义，通常被定义为整数常量 `0` 或 `(void*)0`。
    - **问题**：由于其本质是整数，它会与整数类型的重载函数产生歧义。编译器在某些情况下会将其视为整数，而非空指针，从而导致意外的函数调用。
- **`nullptr`**：
    - **本质**：一个**关键字**，代表一个类型为 `std::nullptr_t` 的**空指针常量**。
    - **优点**：`std::nullptr_t` 可以**隐式地转换为任何指针类型**，但**不能**转换为整数类型（除了布尔类型）。这使得编译器能够明确区分空指针和整数，从而解决了 `NULL` 带来的歧义问题。
#### **2. 歧义性示例**

你提供的代码示例完美地展示了 `NULL` 的类型不安全性：
```cpp
void func(int i) {
    std::cout << "调用 func(int)" << std::endl;
}

void func(int* p) {
    std::cout << "调用 func(int*)" << std::endl;
}

int main() {
    func(NULL);      // 可能调用 func(int)，而非 func(int*)
    func(nullptr);   // 明确调用 func(int*)
}
```

- `func(NULL)`：因为 `NULL` 本质上是整数 `0`，编译器会选择**更匹配**的 `func(int)` 重载版本。如果同时存在 `func(long)` 或其他整数类型重载，则可能出现编译错误，提示“二义性调用”。
    
- `func(nullptr)`：`nullptr` 的类型 `std::nullptr_t` 只能转换为指针类型，所以编译器会毫无疑问地选择 `func(int*)`。

#### **3. 总结与推荐**

|特性|`nullptr`|`NULL`|
|---|---|---|
|**本质**|C++11 关键字|预处理宏 (`#define`)|
|**类型**|`std::nullptr_t` (空指针类型)|整数常量 `0`|
|**安全性**|类型安全，无歧义|弱类型安全，可能引起重载歧义|
|**使用**|推荐，现代 C++ 的最佳实践|不推荐，仅为兼容 C 语言而保留|

#### **结论**

在现代 C++ 编程中，应**始终使用 `nullptr` 来表示空指针**。它不仅能够避免因类型转换而导致的潜在错误，还能让代码的意图更加清晰，提高了代码的健壮性和可读性。