简要回答：
在C++中，禁止类被继承的核心方法是使用**final关键字**（C++11及以上标准）。

当final修饰类时，该类成为“最终类”，任何尝试继承它的派生类都会导致编译错误。

此外，C++11之前可通过**基类构造函数私有化+虚继承+友元类**的组合实现类似效果，但这种方式复杂且易出错，现已被final取代。

#### 详细回答

#### **核心方法：使用 `final` 关键字**（C++11及以上）

- **原理**：`final` 关键字通过编译器的**静态检查机制**实现。当你在一个类的声明后面加上`final`时，编译器会在编译阶段检查所有尝试继承该类的派生类。一旦发现继承行为，就会立即报错，从而阻止编译通过。
- **语法**：在类名后面直接加上 `final` 关键字。

    ```cpp
    class Base final { 
        // 类的定义
    };
    
    // 尝试继承 Base 会导致编译错误
    // class Derived : public Base { };
    ```
- **优点**：
    - **语义明确**：代码清晰地表达了设计意图。
    - **编译时安全**：错误在编译阶段就被捕获，避免了运行时问题。
    - **性能优化**：`final` 可以帮助编译器进行**去虚拟化（Devirtualization）优化。编译器可以确定虚函数调用的具体实现，将间接的虚函数调用优化为直接的函数调用，甚至内联调用**，从而消除虚表查找的开销，提升性能。

2. C++11之前的替代方案（不推荐）
  在C++11之前，没有`final`关键字，开发者通常会采用一种复杂且容易出错的组合技术：**私有化基类构造函数 + 虚继承 + 友元类**。
- **原理**：这种方法通过**访问控制**和**虚继承的特性**来间接阻止继承。
    
    1. 将基类的构造函数设置为**私有（private）**，防止其他类直接创建或继承。
        
    2. 需要继承该类的子类（如 `Derived`）被声明为基类的**友元（friend）**，这样它才能访问基类的私有构造函数。
        
    3. 子类必须**虚继承（virtual public）**基类，这会强制其直接调用基类的构造函数，而进一步的子类则无法访问，从而实现禁止继承的目的。
        
- **示例**：
    ```cpp
    class MakeFinal {
    private:
        MakeFinal() {} 
        friend class Derived; // 声明友元
    };
    
    class Derived : virtual public MakeFinal { // 虚继承
    public:
        Derived() {} 
    };
    
    // FurtherDerived 无法访问 MakeFinal 的私有构造函数，因此编译失败
    // class FurtherDerived : public Derived {};
    ```
    
- **缺点**：
    
    - **复杂**：实现方式复杂，难以理解和维护。
        
    - **不安全**：如果开发者不熟悉虚继承的细节，很容易引入错误。
        
    - **性能开销**：虚继承本身会带来一定的运行时开销。
综上所述，在现代C++编程中，**`final`关键字是禁止类被继承的唯一推荐方法**，因为它简洁、安全且能带来性能上的好处。