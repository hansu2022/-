### 【简要回答】

在 C++ 中，`extern` 关键字主要用于**声明全局变量或函数**，告知编译器这些变量或函数的定义位于其他文件中，从而实现跨文件共享。其核心作用包括：

1. **变量声明**：
    `extern int x; // 声明（不分配内存），定义需在其他文件中`
2. **C++ 与 C 混合编程**：
    `extern "C" { /* C函数声明 */ } // 告诉C++编译器按C语言规则链接`
3. **防止重复定义**： 在头文件中用 `extern` 声明变量，源文件中定义，避免多重定义错误。


### 外部链接（`extern`）

`extern` 是一个 C++ 关键字，主要用于**声明**全局变量或函数，告诉编译器这些变量或函数的定义在**其他源文件**中。这使得程序可以进行**分离式编译**，将代码分散在多个文件中，并在链接时将它们组合起来。

- **核心作用**:
    1. **实现跨文件共享**: 允许一个文件访问另一个文件中定义的全局变量或函数。
    2. **防止重复定义**: 在头文件中使用 `extern` 声明全局变量，并在一个源文件中进行定义，可以避免多个源文件重复定义同一个变量导致的链接错误。
- **`extern` 的本质**: `extern` 告诉编译器，一个符号（变量或函数）拥有**外部链接（External Linkage）**属性，这意味着它可以在程序的整个生命周期和所有编译单元（源文件）中被访问。
#### 1.符号的声明与定义

声明是指告诉编译器某个符号的存在，在程序变量表中记录类型和名字，而定义则是指为该符号分配内存空间或实现其代码逻辑。
**凡是没有带extern的声明同时也都是定义**。  
而对函数而言，带有{}是定义，否则是声明。如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，且不要显式的初始化变量。
```cpp
// 声明
extern int global_var;

// 定义
int global_var = 42;
```

```cpp
// 声明
int sum(int a, int b);

// 定义
int sum(int a, int b) {
  return a + b;
}
```

### 2.C/C++ 中链接属性

#### 外部链接
外部链接的符号可以在不同的源文件之间共享，并且在整个程序执行期间可见。全局变量和函数都具有外部链接

#### 内部链接
内部链接的符号只能在当前源文件内部使用，不能被其他源文件访问。用 `static` 修饰的全局变量和函数具有内部链接

#### 无链接
无链接的符号只能在当前代码块（函数或代码块）内部使用，不能被其他函数或代码块访问。用 `const` 或 `constexpr` 修饰的常量具有无链接属性（ 通常情况下编译器是不会为const对象分配内存，也就无法链接）

### 外部 C 链接(External C Linkage)
外部 C 链接的符号与外部链接类似，可以在不同的源文件之间共享，并且在整个程序执行期间可见。
它们具有 C 语言的名称和调用约定，可以与 C 语言编写的代码进行交互。
在 C++ 中，可以用 `extern "C"` 关键字来指定外部 C 链接，从而使用一些 C 的静态库。


### 3.extern作用
```cpp
//fileA.cpp
int i = 1;         //声明并定义全局变量i

//fileB.cpp
extern int i;    //声明i，链接全局变量

//fileC.cpp
extern int i = 2;        //错误，多重定义
int i;                    //错误，这是一个定义
						//凡是没有带extern的声明同时也都是定义

main()
{
    extern int i;        //正确
    int i = 5;            //正确，新的局部变量i;
}
```
`fileA.cpp` 提供了全局变量 `i` 的**唯一一次定义**，为其分配了内存。`fileB.cpp` 使用 `extern` 对其进行了**声明**，告诉编译器这个变量存在于别处，这不会分配内存，只是为了引用。

`int i = 5;` 则创建了一个**同名的局部变量**，它会**遮蔽**同名的全局变量，这是局部作用域优先的规则

### `extern "C"` 链接指示符

`extern "C"` 是一个 C++ 特有的链接指示符，它告诉 C++ 编译器以 C 语言的规则来处理被它修饰的代码块中的函数或变量。

- **为什么需要 `extern "C"`？**
    
    C++ 支持**函数重载**，为了区分同名但参数不同的函数，C++ 编译器会对函数名进行**名称修饰（Name Mangling）**。例如，一个名为 `int add(int, int)` 的函数在 C++ 编译器内部可能会被修饰为 `_Z3addii`。
    
    而 **C 语言不支持函数重载**，因此它的函数名不会被修饰，编译器会直接使用原始的函数名。
    
    当 C++ 程序调用一个 C 语言编写的函数时，如果 C++ 编译器按照自己的规则对函数名进行修饰，而链接器在 C 语言库中找不到这个修饰后的名称，就会导致**链接错误**。
    
- **`extern "C"` 的作用**:
    
    - `extern "C"` 指示 C++ 编译器，不要对这个函数或变量的名字进行修饰，而是保持其 C 语言风格的原始名称。
        
    - 这使得 C++ 程序可以正确地找到并链接 C 语言库中的函数。
#### 示例: C++ 调用 C 库函数

假设有一个 C 语言库 `clib.h` 和 `clib.c`，其中定义了一个 `int sum(int, int)` 函数。

- **`clib.h` (C 头文件)**
    ```c
    // clib.h
    int sum(int a, int b);
    ```
    
- **`main.cpp` (C++ 源文件)**
```cpp
    // main.cpp
    #include <iostream>
    
    // 告诉C++编译器，接下来声明的函数要按照C语言的链接规则来处理
    extern "C" {
        #include "clib.h" // 包含C头文件
    }
    
    int main() {
        int result = sum(5, 3);
        std::cout << "Sum is: " << result << std::endl;
        return 0;
    }
    ```
    
    在这个例子中，`extern "C"` 确保 `sum` 函数的名字不会被 C++ 编译器修饰，从而使得 C++ 程序能够成功链接到 C 库中未被修饰的 `sum` 函数。