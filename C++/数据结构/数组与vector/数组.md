```cpp
// 定义一个大小为 10 的静态数组
int arr[10];

// 用 memset 函数把数组的值初始化为 0
memset(arr, 0, sizeof(arr));

// 使用索引赋值
arr[0] = 1;
arr[1] = 2;

// 使用索引取值
int a = arr[0];
```
### 1. 数组的本质：连续的内存空间

当你声明一个静态数组，例如 `int arr[10];`，编译器会在**栈**上为你分配一块**连续的内存空间**。

- **内存大小：** 这块空间的大小由数组的元素个数和每个元素类型的大小决定。在 32 位系统下，一个 `int` 通常是 4 字节，所以 `int arr[10]` 的总大小是 10×4=40 字节。
    
- **数组名：** 数组名 `arr` 本身是一个**常量指针**，它存储着这块连续内存空间的**起始地址**。这个地址是数组中第一个元素（`arr[0]`）的地址。由于它是常量指针，所以你不能修改它的值（比如 `arr = arr + 1;` 是非法的）。

### 2. 索引访问：O(1) 的奥秘

数组之所以能实现**随机访问（Random Access）**，并且时间复杂度为 O(1)，正是因为它在内存中是连续存放的。

- **索引的含义：** 数组的索引本质上是**偏移量**。`arr[i]` 并不是一个独立的变量，而是一种语法糖。
    
- **地址计算：** 编译器会通过以下公式计算出 `arr[i]` 的确切内存地址：
<center>    目标地址=数组首地址+索引×元素类型大小</center>

例如，`arr[1]` 的地址就是 `arr` 的首地址加上 1×sizeof(int) 字节的偏移量。由于这个计算和内存寻址操作都非常快，所以无论数组有多大，访问任何一个元素都只需要固定的时间，这就是 O(1) 的由来。
### 3. 数组初始化

- **未初始化的数组：** 如果只声明数组而不进行初始化，比如 `int arr[10];`，那么数组中的值是**不确定**的（通常是内存中已有的“垃圾”数据）。这是因为操作系统分配给你的这块内存可能之前被其他程序使用过。
- **初始化的方法：**
    - **大括号初始化：** `int arr[10] = {1, 2, 3};`。如果提供的元素少于数组大小，剩余的元素会被默认初始化为 0。
    - **全部初始化为 0：** `int arr[10] = {};` 或者 `int arr[10] = {0};`。这两种方式都会将所有元素初始化为 0。
    - **`memset` 函数：** 使用 `memset(arr, 0, sizeof(arr));` 是一种效率很高的方法，它会把指定内存区域的每一个字节都设为 0。
### 4. 数组与指针的关系

在 C++ 中，数组和指针之间有着紧密的联系。

- **数组名作为指针：** 在大多数表达式中，数组名会**隐式地退化（decay）**为一个指向其首元素的指针。例如，`cout << arr;` 会打印数组的首地址。
    
- **解引用操作：** `*arr` 和 `arr[0]` 效果相同，都表示数组的第一个元素。
    
- **指针算术：** `*(arr + 1)` 效果和 `arr[1]` 相同。这里的 `+1` 并不是简单的地址加 1 字节，而是根据指针指向的类型（这里是 `int`）自动增加一个元素大小的偏移量。

### 为什么数组的索引从 0 开始？
就是方便取地址。`arr[0]` 就是 `arr` 的首地址，从这个地址往后的 4 个字节存储着第一个元素的值；`arr[1]` 就是 `arr` 的首地址加上 `1 * 4` 字节，也就是第二个元素的首地址，这个地址往后的 4 个字节存储着第二个元素的值。`arr[2], arr[3]` 以此类推。

## [增删查改](https://labuladong.online/algo/data-structure-basic/array-basic/#%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9)

**数据结构的职责就是增删查改**，再无其他。

那么刚刚介绍数组这种数据结构的底层原理，我们其实只介绍了「查」和「改」的部分，也就是通过索引修改和访问对应元素的值。那么「增删」这两个操作又是如何实现的呢？

### [增](https://labuladong.online/algo/data-structure-basic/array-basic/#%E5%A2%9E)

要想给静态数组增加元素，这就有些复杂了，需要分情况讨论。

1. 数组末尾追加元素（Append）

比方说，我有一个大小为 10 的数组，里面装了 4 个元素，现在想在末尾追加一个元素，怎么办？

比较简单，直接在对应的索引赋值就行了，这是大概的代码逻辑：

```cpp
// 大小为 10 的数组已经装了 4 个元素
int arr[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 现在想在数组末尾追加一个元素 4
arr[4] = 4;

// 再在数组末尾追加一个元素 5
arr[5] = 5;

// 依此类推
// ...
```

**时间复杂度：** **O(1)**。因为这只是一个简单的赋值操作，不涉及任何数据搬移。

2. 数组中间插入元素（Insert）

比方说，我有一个大小为 10 的数组 `arr`，前 4 个索引装了元素，现在想在第 3 个位置（索引 2 `arr[2]`）插入一个新元素，怎么办？
- **实现方式：** 将待插入位置以及其后的所有元素都向后移动一位，为新元素腾出空间，然后再进行插入。

```cpp
// 大小为 10 的数组已经装了 4 个元素
int arr[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// 在索引 2 置插入元素 666
// 需要把索引 2 以及之后的元素都往后移动一位
// 注意要倒着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}

// 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666;
```
**时间复杂度：** **O(N)**。因为最坏情况下，你需要移动几乎所有元素，移动元素的次数与数组中已有的元素数量 N 成正比。
3. 数组扩容（Resize）
当静态数组的空间已经用尽，无论是追加还是插入，你都无法在原有的内存块上操作。你需要进行**扩容**。
- **实现方式：**
    1. **申请新内存：** 在内存中重新申请一块**更大**的连续内存空间。
    2. **数据搬移：** 将旧数组中的所有元素**复制**到新数组中。
    3. **插入新元素：** 在新数组中执行追加或插入操作。
```cpp
// 假设旧数组arr已装满10个元素
int arr[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// 重新创建更大的新数组
int newArr[20];

// 复制旧数组中的元素到新数组
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}

// 在新数组中追加新元素
newArr[10] = 10;
// C++中，对于栈上的静态数组，内存是自动释放的
```
**时间复杂度：** **O(N)**。这个操作的耗时主要集中在**数据复制**上，复制的元素数量与旧数组的元素数量 N 成正比。

### [删](https://labuladong.online/algo/data-structure-basic/array-basic/#%E5%88%A0)

和插入操作类似，静态数组的删除操作也面临着保持内存连续性的挑战。由于数组的元素必须紧密地排列在一起，删除中间的元素会导致一个“空洞”，必须通过数据搬移来填补这个空洞。

#### 1. 删除末尾元素

删除数组末尾的元素是最简单的操作。

- **实现方式：** 你只需要将逻辑上的数组“长度”减一即可。你提到的用一个特殊值（如 `-1`）来标记，在实际应用中是可行的，但这并不从根本上“删除”该元素，它只是告诉我们这个位置是“空”的。更常见的方法是维护一个表示当前数组元素个数的变量，每次删除末尾元素时，只需将该变量减一。

```cpp
// 大小为 10 的数组已经装了 5 个元素
int arr[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1;
```

**时间复杂度：** **O(1)**。这是一个非常高效的操作，因为它不涉及任何数据搬移，只是一个简单的变量更新。
#### 2. 删除中间元素

删除数组中间的元素是复杂且耗时的。

- **实现方式：** 为了填补被删除元素留下的“空洞”，你需要将该位置之后的所有元素都**向前移动一位**。
- **代码逻辑：**

```cpp
// 大小为 10 的数组已经装了 5 个元素
int arr[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// 删除 arr[1]
// 需要把 arr[1] 之后的元素都往前移动一位
// 注意要正着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}

// 最后一个元素置为 -1 代表已删除
arr[4] = -1;
```
**时间复杂度：** **O(N)**。最坏情况下，你需要移动几乎所有元素，移动次数与数组中已有的元素数量 N 成正比。

### [总结](https://labuladong.online/algo/data-structure-basic/array-basic/#%E6%80%BB%E7%BB%93)

综上，静态数组的增删查改操作的时间复杂度是：

- 增：
    - 在末尾追加元素：O(1)O(1)。
    - 在中间（非末尾）插入元素：O(N)O(N)。
- 删：
    - 删除末尾元素：O(1)O(1)。
    - 删除中间（非末尾）元素：O(N)O(N)。
- 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)O(1)。
- 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)O(1)。