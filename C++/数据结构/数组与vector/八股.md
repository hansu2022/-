## vector和array的使用场景分别是什么？ （考点：vector与array的使用场景）【简单】

### 一、基本介绍

| 特性       | `std::vector`            | `std::array`                 |
| -------- | ------------------------ | ---------------------------- |
| **大小**   | 运行时动态可变                  | **编译时**固定不变                  |
| **内存分配** | **堆**（heap），涉及动态内存分配     | **栈**（stack），或全局/静态数据区，无额外开销 |
| **效率**   | 略慢（堆操作开销、数据搬移）           | **零开销抽象**，与C风格数组效率相当         |
| **数据访问** | 支持下标 `[]` 和 `at()`，以及迭代器 | 支持下标 `[]` 和 `at()`，以及迭代器     |
| **标准库**  | C++98 起                  | C++11起                       |

---

### 二、`std::vector` 使用场景

`std::vector` 适用于那些**数据量在运行时才能确定**，或**需要频繁增删元素**的场景。它提供了动态扩容和缩容的能力，极大地简化了内存管理。
**主要应用场景：**
- **处理未知大小的数据集：** 例如，从文件中读取用户输入，或者网络接收的数据包，你无法预知具体有多少数据，`vector` 会自动帮你管理内存。
- **需要动态增删元素的容器：** 在实现栈、队列或者图的邻接表等数据结构时，元素的数量会不断变化。
- **与其他 STL 算法协同工作：** `vector` 完美适配了 `<algorithm>` 头文件中的各种算法，例如排序、查找等，因为其提供了标准的迭代器接口。

### 三、`std::array` 使用场景

`std::array` 的设计初衷是为了替代传统的**C风格数组**（`int arr[10]`）。它在保持与C风格数组同样高效的性能基础上，增加了C++标准库容器的优势。

**主要应用场景：**

- **编译时大小已知：** 当数组的元素个数在编译时就已经确定，并且不会再改变时，`std::array` 是最好的选择。例如，存储一个坐标、一个颜色向量或者一周七天的名称。
    
- **高性能计算：** 由于它在栈上分配内存且没有动态分配的开销，这使得它在性能要求极高的场景下比 `std::vector` 更有优势。
    
- **与 STL 算法集成：** 像 `std::sort`、`std::for_each` 这样的算法可以轻松地应用在 `std::array` 上，这比使用C风格数组更方便。
#### 4. 对比传统数组的优势补充
- **类型安全和边界检查：** `std::array` 提供了 `.at()` 方法进行边界检查，这可以帮助你在开发阶段发现索引越界错误。而传统的C风格数组不具备这个能力。
- **支持容器操作：** `std::array` 拥有 `.size()`、`.empty()` 等成员函数，以及方便的迭代器接口，使得代码更具可读性和可维护性。
- **避免指针退化：** 传统的C风格数组在作为函数参数传递时，会**退化为指针**，这导致函数内部无法获知数组的原始大小。`std::array` 通过值传递或引用传递的方式，可以避免这个问题。

### 四、总结对比 🎯

| 使用需求      | 推荐容器                         |
| --------- | ---------------------------- |
| 需要动态增长    | `std::vector`                |
| 固定长度、性能敏感 | `std::array`                 |
| 使用旧C风格数组  | 原始数组 `T arr[N]`              |
| 与C接口交互    | 原始数组 或 `std::vector::data()` |

## 你能描述一下vector是如何保证元素连续存储的吗？ （考点：vector的内存管理）【简单】

vector内部使用**动态数组**作为底层存储结构，内部使用了一个**单一的内存块**来存储所有的元素，并且管理这个内存块的大小和容量。当vector的内存容量不够时，会重新分配一块更大的内存，再把旧的数组中的数据复制到新的内存块中

## 当vector的空间不足以容纳更多元素时，它是如何扩容的？ （考点：vector的动态扩容机制）【中等】

当 `vector` 的空间不足时，它的扩容过程是一个经典的**空间换时间**的策略，其目的是为了保证**在均摊意义上（Amortized）**，`push_back` 的操作复杂度仍然是 O(1)
`vector` 扩容并非在原地简单地增加内存。由于其底层是**连续的内存空间**，这块空间后面的内存可能已经被其他数据占用，所以它无法直接在末尾“长”出更多的空间。

当 `vector` 的当前大小（`size`）等于容量（`capacity`）时，任何新的元素插入（例如 `push_back`）都会触发扩容。扩容过程分为以下三个步骤：
1. **分配新内存：** `vector` 会向操作系统申请一块**更大**的、**连续的**内存空间。新的容量通常是旧容量的 **1.5 倍或 2 倍**（C++ 标准没有强制规定具体倍数，但主流实现都是 2 倍）。
2. **数据搬移：** 将旧内存地址上的所有元素，**逐个复制**或**移动**到新的内存地址上。
3. **释放旧内存：** 销毁旧内存地址上的所有元素，并把这块内存归还给操作系统。

这个过程你可以想象成，你的公寓（旧内存）住满了，你不能简单地在旁边加一个房间，而是要搬家到一个更大的新公寓（新内存），把所有家具（元素）都搬过去，然后退掉旧公寓。

### 扩容的时间复杂度

扩容操作的耗时主要集中在**数据搬移**上，这个时间复杂度与原数组的元素数量成正比，即 **O(N)**。

正是因为这个 O(N) 的开销，使得 `vector` 的扩容操作非常昂贵。如果 `vector` 频繁扩容，性能就会大打折扣。
### 为什么选择成倍扩容？（摊还分析）

为了避免频繁的 O(N) 扩容开销，`vector` 采用了“**指数级增长**”的策略。

假设 `vector` 的初始容量为 1，每次扩容都翻倍。当它需要存储 N 个元素时，会经历以下容量变化：

1→2→4→8→16→⋯→N

整个过程中，数据搬移的总次数是：1+2+4+8+⋯+N/2=N−1。

可以看到，总的搬移次数大约是 N。这意味着，在向 `vector` 中插入 N 个元素的过程中，虽然有几次操作是昂贵的 O(N)，但**总的开销**是线性的 O(N)。因此，我们可以说**单次** `push_back` 操作的**平均**时间复杂度是 **O(1)**。

这种分析方法称为**摊还分析（Amortized Analysis）**。它将偶尔发生的昂贵操作的成本，分摊到所有操作上，从而得出一个平均的时间复杂度。
### 如何避免频繁扩容？

如果你事先知道 `vector` 需要存储多少元素，可以使用 `reserve()` 方法来预分配内存，从而避免不必要的扩容：

```cpp
#include <vector>

int main() {
    std::vector<int> nums;
    // 提前分配100个元素的空间，避免多次扩容
    nums.reserve(100); 

    for (int i = 0; i < 100; ++i) {
        nums.push_back(i); // 此时不会发生扩容
    }
    return 0;
}
```

使用 `reserve()` 是一种重要的性能优化手段，尤其是在向 `vector` 中插入大量数据时。

## vector在拷贝时使用的是什么方法？

`vector` 扩容时，它会优先使用**移动语义**（Move Semantics）来搬运元素，而不是传统的深拷贝（Deep Copy）。这在 C++11 之后是一个重要的性能优化。
#### 1. 传统方式：深拷贝 (Deep Copy)

在 C++11 之前，`vector` 扩容时，会逐个调用元素的**拷贝构造函数**。

- **什么是深拷贝？** 比如你有一个 `vector<string>`，每个 `string` 内部都管理着一块动态分配的内存来存储字符串数据。当你拷贝一个 `string` 对象时，它会重新分配一块新的内存，并将原始字符串的内容逐一复制过去。
    
- **深拷贝的开销：** 这个过程会创建新的内存，并进行数据复制，非常耗时。当 `vector` 里存储的是像 `std::string` 或其他包含堆内存的复杂对象时，这种开销尤为显著。
    

#### 2. C++11 之后：移动语义 (Move Semantics)

C++11 引入了**右值引用**和**移动语义**，这极大地优化了 `vector` 的扩容效率。

- **什么是移动语义？** 简单来说，移动语义就是把**资源的所有权**从一个对象转移到另一个对象，而不是复制资源本身。这就像是“搬家”：你不是把所有家具都重新买一遍（深拷贝），而是直接把它们从旧公寓搬到新公寓（移动）。
    
- **移动的开销：** 对于 `string` 这样的对象，移动操作通常只是简单地**交换内部指针**，然后将旧对象的指针置为空。它不涉及任何新的内存分配或数据复制，开销非常小，通常是 O(1)。
#### `std::vector` 为什么能使用移动语义？

当 `vector` 扩容时，旧数组中的元素即将被销毁。这意味着，这些元素是**临时对象**，它们的资源可以被“偷走”而不会有任何副作用。这就是移动语义发挥作用的完美场景。

在 C++11 之后，`vector` 在扩容时会优先调用元素的**移动构造函数**。如果元素类型没有提供移动构造函数，编译器会退而求其次，调用其拷贝构造函数。因此，如果你在自定义的类中实现了移动构造函数，可以显著提升 `vector` 扩容的性能。

vector扩容时，是使用移动语义复制对象还是直接拷贝对象，取决于对象是否支持移动语义，实现了移动构造函数

所以，现代 C++ 中，`vector` 扩容时的搬运效率已经大大提高，但请记住，这仍然是一个昂贵的**数据搬移**操作，它只是在**单次操作**上进行了优化，其**摊还**时间复杂度依然依赖于成倍扩容的策略。

## vector的push_back和emplace_back有什么区别？ （考点：vector的元素添加方式）【简单】

#### 【简要回答】

std::vector的push_back和emplace_back都用于在向量的末尾添加元素，但它们添加元素的方式不同：

- `push_back`：创建一个元素的副本或移动该元素，然后将其添加到向量的末尾。
- `emplace_back`：在向量的末尾就地构造元素，避免了额外的复制或移动。

#### 【详细回答】

**push_back**：

- push_back方法接受一个参数，该参数可以是一个值、一个已存在的对象的引用，或者是要添加到向量末尾的元素的右值。
- 如果参数是一个右值，push_back将使用移动构造函数（如果可用）来移动它；如果参数是一个左值，它将使用复制构造函数来复制它。
- push_back在向量需要扩容时，可能会导致向量中的所有元素被复制或移动到新的内存位置。

**emplace_back**：

- emplace_back不接受任何直接的参数，但它接受构造新元素所需的参数，并使用这些参数列表在向量的末尾就地构造一个新元素。
- emplace_back避免了临时对象的创建和销毁，因为它直接在向量内存空间内构造对象。
- emplace_back不会触发向量内存的重新分配，除非向量已经达到了它的容量上限。

#### 【知识拓展】

1. 性能：emplace_back通常比push_back更高效，因为它省去了临时对象的创建和销毁的开销，特别是在构造和析构成本较高时。
    
2. 适用场景：当你需要传递多个参数来构造向量末尾的元素时，emplace_back是一个很好的选择，因为它允许你直接传递这些参数给构造函数。
    
3. 完美转发：emplace_back能够完美转发参数，这意味着参数的值类别（左值、右值）会被保留，这对于需要区分处理左值和右值的构造函数特别有用。
    
4. 内存分配：push_back在添加元素时可能会触发内存分配，因为向量可能需要扩容；而emplace_back只有在向量容量不足以容纳新元素时才会触发内存分配。
    

`#include <vector> #include <string>  int main() {    std::vector<std::string> v;     // 使用push_back添加元素    v.push_back("Copy or move this string");     // 使用emplace_back就地构造元素    v.emplace_back("Constructed in place");     return 0; }`