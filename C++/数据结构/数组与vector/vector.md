### [关键点一、自动扩缩容](https://labuladong.online/algo/data-structure-basic/array-implement/#%E5%85%B3%E9%94%AE%E7%82%B9%E4%B8%80%E3%80%81%E8%87%AA%E5%8A%A8%E6%89%A9%E7%BC%A9%E5%AE%B9)

`vector` 能够自动调整大小，其核心在于一个**容量（capacity）**和**大小（size）**的概念。

- **大小（size）：** 数组中**实际**存储的元素个数。
- **容量（capacity）：** 底层静态数组**能容纳**的最大元素个数。
`capacity` 总是大于或等于 `size`。当 `size` 达到 `capacity` 的上限时，就会触发**扩容**。

- **扩容策略：** 扩容通常不是每次只增加一个元素空间，而是**成倍扩容**（例如，`capacity` 变为原来的 2 倍），以避免频繁地进行耗时的内存分配和数据搬移。
    
- **缩容策略：** 为了节省内存，当 `size` 远小于 `capacity` 时，会触发**缩容**。你的缩容策略（当 `size` 缩减到 `capacity` 的 1/4 时，缩容为 1/2）是一种常见的优化方案。它引入了一个“**滞后因子**”，防止在频繁增删元素时反复扩容和缩容，造成性能抖动。

### [关键点二、索引越界的检查](https://labuladong.online/algo/data-structure-basic/array-implement/#%E5%85%B3%E9%94%AE%E7%82%B9%E4%BA%8C%E3%80%81%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E7%9A%84%E6%A3%80%E6%9F%A5)

`vector` 提供了两种访问元素的方式，反映了你提到的两种索引检查策略：
- **`[]` 操作符：** 类似于 C 语言数组的 `arr[i]`，它不执行任何边界检查。如果你传入一个非法的索引，可能会导致未定义行为（Undefined Behavior），即程序可能崩溃或产生不可预测的结果。
- **`at()` 方法：** 类似于你的 `checkElementIndex`，它会进行严格的边界检查。如果传入的索引越界，`at()` 方法会抛出一个 `std::out_of_range` 异常，这有助于在开发阶段发现和调试错误。

你对**插入位置**的理解非常精确。在插入操作中，`size` 和 `capacity` 之间的“空隙”都是合法的插入位置。因此，插入操作的索引边界检查通常是 `0 <= index <= size`。

### [关键点三、删除元素谨防内存泄漏](https://labuladong.online/algo/data-structure-basic/array-implement/#%E5%85%B3%E9%94%AE%E7%82%B9%E4%B8%89%E3%80%81%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%B0%A8%E9%98%B2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)

你的分析非常到位，尤其是在 Java 环境中，**将不再使用的引用置为 `null` 是避免内存泄漏的关键**
- **垃圾回收（Garbage Collection）：** 在 Java 等具有垃圾回收机制的语言中，垃圾回收器通过**可达性分析**来判断一个对象是否可被回收。如果一个对象仍被某个引用指向，它就是“可达”的，垃圾回收器就不会释放其内存。
- **内存泄漏风险：** 当你在数组中删除一个元素时，即使该元素逻辑上已不存在，但它在底层数组中的引用仍然存在。如果你不将该引用置为 `null`，垃圾回收器会误认为该对象仍然在使用中，从而导致内存泄漏。

### [其他细节优化](https://labuladong.online/algo/data-structure-basic/array-implement/#%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82%E4%BC%98%E5%8C%96)

下面的代码当然不会是一个很完善的实现，会有不少可以进一步优化的点。比方说，我是用 for 循环复制数组数据的，实际上这种方式复制的效率比较差，大部分编程语言会提供更高效的数组复制方法，比如 Java 的 `System.arraycopy`。

不过它再怎么优化，本质上也是要搬移数据，时间复杂度都是 O(n)O(n)。本文的重点在于让你理解数组增删查改 API 的基本实现思路以及时间复杂度，如果对这些细节感兴趣，可以找到编程语言标准库的源码深入研究。