顶层const 作用变量本身，该变量不可修改,这个指针不能指向另一个地址。
```cpp
int a = 10;
int b = 20;
int* const p = &a;  // 声明一个只读指针，指向 a
*p = 30;  // 合法，可以通过指针修改 a 的值
p = &b;  // 非法，无法修改只读指针的值
```
底层const 作用指针或引用本身的对象，不能通过该变量修改指向的对象,不能通过 `p` 来修改所指向的值。
```cpp
const int* p;  // 声明一个指向只读变量的指针，可以指向 int 类型的只读变量
int a = 10;
const int b = 20;
p = &a;  // 合法，指针可以指向普通变量
p = &b;  // 合法，指针可以指向只读变量
*p = 30;  // 非法，无法通过指针修改只读变量的值
```

```cpp
int a = 10;
const int& p = a; // p 是一个 const 引用，它绑定到 a
// p = 20; // 错误：不能通过 p 修改 a 的值
a = 30;              // 正确：a 本身不是 const，可以直接修改
std::cout << p; // 输出 30
```
##### 指针

指针是**存储内存地址**的变量，通过声明（如int* p = &a），其**值为目标对象的地址**。

底层实现上，**指针**变量占用**独立内存**（32位系统4字节，64位系统8字节）。

可以**重新赋值**（如p = &b），支持指针算术（如p++移动地址）

**可为nullptr**，表示不指向有效对象，但需注意，未初始化或未判空的指针可能导致**野指针**，可能引发崩溃。
指针的const的修饰，其取决于const的修饰位置

1. const int *p：const修饰的是**指针指向的对象**，不能通过指针修改对象的值，但可以改变指针本身指向的对象。表示不能通过 `p` 来修改所指向的值。
2. int *const p：const修饰的是**指针本身**，不能改变指针指向的对象，但可以改变指针本身。表示 `p` 这个指针不能指向另一个地址。
3. const int *const p：const修饰的是**指针指向的对象和指针本身**，不能通过指针修改对象的值，也不能改变指针本身。

指针的灵活性使其在动态内存分配、数组操作、字符串处理及复杂数据结构（如链表、树）中非常有用，但需**手动管理内存**，否则容易造成**内存泄漏**。

##### 引用

引用是**变量的别名**（如int& r = a），绑定后与目标共享内存，**无独立存储空间**。

编译时符号表记录引用目标的地址，绑定关系一旦建立，无法更改。

引用**必须初始化且不能为空**，语法上更简洁，直接操作目标变量（如r = 10）。

const：引用只有底层const，引用本身是不能被重新绑定的，所以它总是指向同一个对象，从这个意义上说，引用自身是“常量”的。`const` 关键字加在引用上，修饰的是它所引用的那个对象，而不是引用本身。

由于引用绑定后不可更改，**生命周期与绑定对象一致**，**无需手动管理内存**，因此在函数参数传递、返回值优化等场景中更安全高效。

### 指针和引用演示

```cpp
#include <iostream>
using namespace std;

int main() {
    // ====== 初始化对比 ======
    int a = 10;
    int* ptr;       // 指针可以延迟初始化
    ptr = &a;       // 现在指向a
    ptr = nullptr;  // 可以设为空指针

   int& ref = a;   // 引用必须初始化且不能为空
   // int& ref2;    // 错误：引用必须初始化
   // int& ref3 = nullptr; // 错误：不能绑定到空

   // ====== 重新绑定对比 ======
   int b = 20;
   ptr = &b;       // 指针可以重新指向b
   // &ref = b;     // 错误：引用不能重新绑定

   // ====== 内存占用对比 ======
   cout << "指针大小: " << sizeof(ptr) << " bytes" << endl; // 4或8字节
   cout << "引用大小: " << sizeof(ref) << " bytes" << endl;  // 显示a的大小

   // ====== 操作方式对比 ======
   *ptr = 30;      // 指针需要解引用
   ref = 40;       // 引用直接操作

    // ====== 安全性对比 ======
   if(ptr != nullptr) {  // 使用指针需要判空（行29）
       cout << *ptr << endl;
   }
   cout << ref << endl;  // 引用无需判空检查（行32）

   // ====== 动态内存管理 ======
   int* dynPtr = new int(50);  // 指针用于动态内存
   cout << *dynPtr << endl;
   delete dynPtr;              // 必须手动释放
   // 引用不能用于动态内存管理

   // ====== 函数参数传递 ======
   auto modifyByPtr = [](int* p) { if(p) *p += 1; };
   auto modifyByRef = [](int& r) { r += 1; };
   
   modifyByPtr(&a);
   modifyByRef(a);
   cout << "a = " << a << endl;  // 输出42

   //====== const的修饰 ======
   // 引用示例    
   const int ci = 10;  
   //int& r = ci;  // 错误：非const引用不能绑定到const对象
   const int& cr = ci;  //正确：const引用可以绑定到const对象
    //指针示例
   int a = 10;
   const int* p1 = &a;  // p1指向的值是const的
   //*p1 = 20;  //错误：不能通过p1修改a的值
   int* const p2 = &a;  // p2本身是const的，不能改变指向
   //p2 = &b;  //错误：不能改变p2指向的对象

   return 0;
}

```
![[Pasted image 20250920094406.png]]**在实际编程中，什么情况下应该使用指针，什么情况下应该使用引用？举例子说明。**

- 简答：

1. **什么时候用指针？** 遇到需要处理可能为**NULL**的情况（如可选参数时）遇到需要改变指向的对象（如**遍历链表**时）遇到需要**动态内存分配**（new/delete）遇到需要**多级间接访问**（如指针的指针）
    
2. **什么时候用引用？** **函数参数传递**，特别是大型对象时，可以避免拷贝开销，遇到**必须绑定到有效对象**的场景时（如类成员引用）实现**链式调用**（如返回*this引用）还有**运算符的重载**。
```cpp
// 指针版
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
// 引用版
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```
![[Pasted image 20250920131431.png]]
![[Pasted image 20250920131508.png]]
1. 引用只是C++语法糖，可以看作编译器自动完成取地址、解引用的指针常量
2. 引用区别于指针的特性都是编译器约束完成的，一旦编译成汇编就喝指针一样
3. 由于引用只是指针包装了下，所以也存在风险，比如如下代码:

```
int *a = new int;
int &b = *a;
delete a;
b = 12;    // 对已经释放的内存解引用
```

4. 引用由编译器保证初始化，使用起来较为方便(如不用检查空指针等)
5. 尽量用引用代替指针
6. 引用没有顶层const即`int & const`，因为引用本身就不可变，所以在加顶层const也没有意义； 但是可以有底层const即 `const int&`，这表示引用所引用的对象本身是常量
7. 指针既有顶层const(`int * const`--指针本身不可变)，也有底层const(`const int *`--指针所指向的对象不可变)
8. 有**指针引用**（`int*&`），这是一个引用，它绑定到一个指针变量，常用于在函数中修改传入的指针。但**没有引用指针**的语法（`int&*`），因为引用本身就是一个别名，它的设计初衷就是为了避免像指针那样复杂的语法，如果一个指针可以指向引用，这会使语言的设计变得非常复杂和矛盾。
9. 指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或--
