、`static`关键字主要用于控制变量和函数的生命周期、作用域以及访问权限。
### 【简要回答】

在 C++ 中，`static` 关键字的作用根据使用场景不同而有所区别：

- **局部变量**：添加 `static` 会使其生命周期延长至程序结束，但作用域仍限于函数内部，且只在首次执行时初始化。
- **全局变量 / 函数**：限制其作用域为当前文件，避免被其他文件通过 `extern` 引用。
- **类成员变量 / 函数**：属于类而非对象实例，所有对象共享同一份静态成员，可通过类名直接访问。
## 1. static 修饰全局变量
static 修饰全局变量可以将变量的作用域限定在当前文件中，使得其他文件无法访问该变量。
同时，static 修饰的全局变量在程序启动时被初始化（可以简单理解为在执行 main 函数之前，会执行一个全局的初始化函数，在那里会执行全局变量的初始化），生命周期和程序一样长。

```cpp
// a.cpp 文件
static int a = 10;  // static 修饰全局变量
int main() {
    a++;  // 合法，可以在当前文件中访问 a
    return 0;
}

// b.cpp 文件
extern int a;  // 声明 a
void foo() {
    a++;  // 非法，会报链接错误，其他文件无法访问 a
}
```

关于这里为什么会是非法、报链接错误，可以看看这篇文章：[extern 的作用-从链接角度理解](extern)

## 2. static 修饰局部变量

static 修饰局部变量可以使得变量在函数调用结束后不会被销毁，而是一直存在于内存中，下次调用该函数时可以继续使用。

同时，由于 static 修饰的局部变量的作用域仅限于函数内部，所以其他函数无法访问该变量。

```cpp
void foo() {
    static int count = 0;  // static 修饰局部变量
    count++;
    cout << count << endl;
}

int main() {
    foo();  // 输出 1
    foo();  // 输出 2
    foo();  // 输出 3
    return 0;
}
```

## 3. static 修饰函数

static 修饰函数可以将函数的作用域限定在当前文件中，使得其他文件无法访问该函数。

同时，由于 static 修饰的函数只能在当前文件中被调用，因此可以避免命名冲突和代码重复定义。

```cpp
// a.cpp 文件
static void foo() {  // static 修饰函数
    cout << "Hello, world!" << endl;
}

int main() {
    foo();  // 合法，可以在当前文件中调用 foo 函数
    return 0;
}

// b.cpp 文件
extern void foo(); // 声明 foo
void bar() {
    foo();  // 非法，会报链接错误，找不到 foo 函数，其他文件无法调用 foo 函数
}
```

## 4. static 修饰类成员变量和函数
static 修饰类成员变量和函数可以使得它们在所有类对象中共享，且不需要创建对象就可以直接访问。- 静态成员变量必须在类外部单独定义，以便为其分配存储空间。

```cpp
class MyClass {
public:
    static int count;  // static 修饰类成员变量
    static void foo() {  // static 修饰类成员函数
        cout << count << endl;
    }
};
// 访问：

MyClass::count;
MyClass::foo();
```


- **静态与常量的区别**：
    - `static` 强调存储和作用域，`const` 强调不可修改。
    - 静态常量（如 `static const int`）需在类内声明、类外初始化，但整数类型可在类内直接初始化。
- **静态对象的析构**： 静态对象的析构函数在程序结束时自动调用，顺序与构造相反。
- **线程安全问题**： C++11 起，局部静态变量的初始化是线程安全的（即多线程首次调用函数时，静态变量只会被初始化一次）。
- **静态类（伪概念）**： C++ 没有直接支持 “静态类”，但可通过将构造函数设为私有、仅提供静态成员的方式模拟。
- **静态成员与模板**： 类模板的静态成员会为每个实例化的模板类型单独生成一份实例。