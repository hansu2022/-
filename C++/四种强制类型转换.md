#### 1. static_cast
**没有运行时类型检查来保证转换的安全性**
进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。
**使用：**
1. 用于基本数据类型之间的转换，如把int转换成char。
2. 把任何类型的表达式转换成void类型。
#### 2. dynamic_cast
在进行下行转换时，dynamic_cast具有类型检查（信息在虚函数中）的功能，比static_cast更安全。
转换后必须是类的指针、引用或者void*，基类要有虚函数，可以交叉转换。
dynamic本身只能用于存在虚函数的父子关系的强制类型转换；对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常。
#### 3. reinterpret_cast
可以将整型转换为指针，也可以把指针转换为数组；可以在指针和引用里进行肆无忌惮的转换，平台移植性比价差。
#### 4. const_cast

常量指针转换为非常量指针，并且仍然指向原来的对象。常量引用被转换为非常量引用，并且仍然指向原来的对象。去掉类型的const或volatile属性。
![[Pasted image 20250922142509.png]]
#### 1. static_cast

**特点：**

- **编译时检查**：`static_cast` 在编译时进行类型检查，**不**进行运行时类型检查，因此无法保证转换的安全性。
    
- **主要用途**：用于**上行转换**（派生类指针/引用到基类），这是安全的。
    
- **不安全用途**：用于**下行转换**（基类指针/引用到派生类），因为没有运行时检查，如果实际对象类型不符，将导致未定义行为。

**使用场景：**

1. **基本数据类型转换**：例如 `int` 到 `double`。这是最常见的用途。
    ```cpp
    int a = 42;
    double b = static_cast<double>(a); // 将整数a转换为双精度浮点数b
    ```
    
2. **上行转换**：在类层次结构中，将派生类指针/引用转换为基类指针/引用。
    ```cpp
    class Base {};
    class Derived : public Base {};
    Derived d;
    Base& b_ref = static_cast<Base&>(d); // 安全的上行转换
    ```
    
3. **下行转换（需程序员确保安全）**：将基类指针/引用转换为派生类。
    ```cpp
    Base* b_ptr = new Derived();
    Derived* d_ptr = static_cast<Derived*>(b_ptr); // 程序员必须保证 b_ptr 实际指向一个 Derive
    ```
#### 2. dynamic_cast

**特点：**
- **运行时检查**：`dynamic_cast` 在运行时执行类型检查，依赖于 **运行时类型信息 (RTTI)**，因此比 `static_cast` 更安全。
- **多态要求**：**只能用于含有虚函数**的类层次结构中，因为 RTTI 需要通过虚函数表 (vtable) 来实现。
- **转换失败处理**：
    - **指针**：转换失败时返回 **`nullptr`**。
    - **引用**：转换失败时抛出 `std::bad_cast` 异常。

**底层原理：** `dynamic_cast` 依赖于 RTTI。编译器为多态类（含有虚函数）生成虚函数表（vtable），其中包含指向虚函数和 `type_info` 对象的指针。`dynamic_cast` 通过查询这个 `type_info` 对象来确定对象的实际类型，并检查目标类型是否与实际类型兼容。
**使用场景：**
1. **安全的下行转换**：在多态类中，安全地将基类指针/引用转换为派生类。
```cpp
    class Base { virtual void dummy() {} };
    class Derived : public Base { /* ... */ };
    
    Base* b_ptr = new Derived();
    Derived* d_ptr = dynamic_cast<Derived*>(b_ptr); // 运行时检查，成功
    
    Base* another_ptr = new Base();
    Derived* another_d_ptr = dynamic_cast<Derived*>(another_ptr); // 运行时检查，失败，返回 nullptr
    ```
    
2. **多态类型检查**：在处理多态对象时，用于确定对象的实际类型。
```cpp
    class Animal { public: virtual ~Animal() {} };
    class Dog : public Animal { public: void bark() {} };
    
    Animal* animal_ptr = new Dog();
    
    // 运行时检查 animal_ptr 是否指向 Dog 对象
    if (Dog* dog_ptr = dynamic_cast<Dog*>(animal_ptr)) {
        dog_ptr->bark();
    }
    ```

`dynamic_cast`的底层原理依赖于运行时类型信息（RTTI, Runtime Type Information）。
C++编译器在编译时为支持多态的类生成RTTI，它包含了类的类型信息和类层次结构。
我们都知道当使用虚函数时，编译器会为每个类生成一个虚函数表（vtable），并在其中存储指向虚函数的指针。
伴随虚函数表的还有 RTTI(运行时类型信息)，这些辅助的信息可以用来帮助我们运行时识别对象的类型信息。
《深度探索C++对象模型》中有个例子：
```cpp
class Point
{
public:
	Point(float xval);
	virtual ~Point();
 
	float x() const;
	static int PointCount();
 
protected:
	virtual ostream& print(ostream& os) const;
 
	float _x;
	static int _point_count;
};
```

![](https://cdn.how2cs.cn/csguide/155928.png)

首先，每个多态对象都有一个指向其vtable的指针，称为vptr。

RTTI（就是上面图中的 type_info 结构)通常与vtable关联。
`dynamic_cast`就是利用RTTI来执行运行时类型检查和安全类型转换。
以下是`dynamic_cast`的工作原理的简化描述：
1. 首先，`dynamic_cast`通过查询对象的 vptr 来获取其RTTI（这也是为什么 dynamic_cast 要求对象有虚函数）
2. 然后，`dynamic_cast`比较请求的目标类型与从RTTI获得的实际类型。如果目标类型是实际类型或其基类，则转换成功。
3. 如果目标类型是派生类，`dynamic_cast`会检查类层次结构，以确定转换是否合法。如果在类层次结构中找到了目标类型，则转换成功；否则，转换失败。
4. 当转换成功时，`dynamic_cast`返回转换后的指针或引用。
5. 如果转换失败，对于指针类型，`dynamic_cast`返回空指针；对于引用类型，它会抛出一个`std::bad_cast`异常。
因为`dynamic_cast`依赖于运行时类型信息，它的性能可能低于其他类型转换操作（如`static_cast`），static 是编译器静态转换，编译时期就完成
#### 3. reinterpret_cast

**特点：**
- **重新解释**：`reinterpret_cast` 的意思是 **“重新解释转换”**，它不做任何类型检查或调整，只是简单地将一个值的**比特位模式**转换为另一种类型。
- **最危险**：这是最不安全的类型转换，因为它完全依赖于程序员对内存布局的理解，很容易导致未定义的行为。
- **平台依赖性**：由于它直接操作底层内存，因此具有很差的平台可移植性。
用法: `const_cast <new_type> (expression)`  
new_type 必须是一个指针、引用或者指向对象类型成员的指针。
- **指针和整数的转换**：通常用于将指针存储在整数类型中，或反过来。
    ```cpp
    int a = 42;
    int* int_ptr = &a;
    long long address = reinterpret_cast<long long>(int_ptr); // 将指针转换为整数
    ```
    
- **不相关的指针类型转换**：在不相关的指针类型之间进行强制转换。
    ```cpp
    struct A { int a; };
    struct B { int b; };
    A* a_ptr = new A();
    B* b_ptr = reinterpret_cast<B*>(a_ptr); // 危险！
    ```
#### 4. const_cast

**特点：**
- **唯一用途**：用于**去除**变量的 `const` 或 `volatile` 属性。
- **警告**：仅当原始变量不是真正意义上的常量时（例如，一个 `const` 指针指向一个非 `const` 对象），才能安全地修改它。如果尝试修改一个真正的 `const` 对象，将导致**未定义行为**。

- **修改 `const` 对象**：将 `const` 指针/引用转换为非 `const` 指针/引用，以便修改指向的对象。
    ```cpp
    int a = 42;
    const int* ptr = &a;
    int* mutable_ptr = const_cast<int*>(ptr);
    *mutable_ptr = 43; // OK，因为 a 本身不是 const
    
    // 如果 a 定义为 const int a = 42;
    // 那么 *mutable_ptr = 43; 将导致未定义行为。
    ```
    
- **调用非 `const` 成员函数**：当需要用一个 `const` 对象调用其非 `const` 成员函数时。
    ```cpp
    class MyClass {
    public:
        void non_const_function() {}
    };
    
    const MyClass my_const_obj;
    MyClass* mutable_obj_ptr = const_cast<MyClass*>(&my_const_obj);
    mutable_obj_ptr->non_const_function();
    ```