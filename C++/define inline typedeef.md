### 宏定义（`#define`）

**宏定义**是 C/C++ 预处理器指令，用于在编译前进行简单的文本替换。

- **特点**:
    - **工作阶段**: 在**预处理阶段**进行，早于编译器正式编译代码。
    - **替换方式**: 纯粹的**文本替换**，不进行任何类型检查。
    - **无类型安全**: 由于只是简单的文本替换，可能会导致类型不匹配等运行时错误，且难以发现。
    - **不可调试**: 宏定义在预处理后就不存在了，因此无法在调试器中设置断点或进行调试。
    - **参数多次求值**: 如果宏的参数是表达式，在宏展开时，该表达式可能会被多次求值，导致意想不到的副作用。
1.**宏参数的副作用**:
```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int x = 1;
int y = MAX(x++, 10);
// 展开后: int y = ((x++) > (10) ? (x++) : (10));
// x++ 被执行了两次，导致 x 的值变为 3，而 y 的值变为 10。
// 如果使用内联函数，x++ 只会执行一次。
```
2.**宏参数的括号问题**:
```cpp
#define SQUARE(x) x * x
int a = SQUARE(5 + 2);
// 展开后: int a = 5 + 2 * 5 + 2;
// 结果是 17，而不是预期的 49。
// 正确写法应该是: #define SQUARE(x) ((x) * (x))，为参数和整个表达式都加上括号。
```

### inline
**内联函数**是 C++ 的特性，旨在**消除函数调用带来的性能开销**，同时保留函数的类型检查和可调试性。

- **特点**:
    - **工作阶段**: 在**编译阶段**处理。
    - **类型安全**: 是一个**真正的函数**，会进行严格的类型检查，避免了宏定义带来的隐患。
    - **可调试**: 可以在调试器中设置断点，进行单步调试。
    - **代码膨胀**: 编译器会将内联函数的函数体在调用处进行展开和替换。如果函数体过大或被多次调用，可能会导致最终编译出的可执行文件变大。
    - **编译器决定**: `inline` 关键字只是向编译器发出的**一个建议**，编译器会根据函数的大小、复杂度等因素，自主决定是否进行内联。
        
- **编译器限制**: 为了避免过度膨胀和复杂性，编译器通常只对满足以下条件的函数进行内联：
    - 函数体不包含复杂的控制流（如循环、`switch`）。
    - 函数体不包含递归调用。
    - 函数体不能过于庞大。
    - 内联函数的定义通常放在**头文件**中，以便在调用它的每个源文件中都能被编译器看到并展开。
```cpp
inline int square(int x) {
    return x * x;
}
int main() {
    int a = 5;
    double b = 5.5;

    // 下面这行代码将导致编译错误，因为类型不匹配
    double result = square(b);
}
```
**C++中inline编译限制：**

1. 不能存在任何形式的循环语句
2. 不能存在过多的条件判断语句
3. 函数体不能过于庞大
4. 内联函数声明必须在调用语句之前

### `const` 和 `#define` 的区别

|特性|`const` 定义的常量|`#define` 定义的宏常量|
|---|---|---|
|**生效阶段**|**编译阶段**|**预处理阶段**|
|**内存占用**|在 C++ 中，`const` 常量通常**存储在符号表**中，不占用实际内存；而在 C 语言中，`const` 常量会**分配内存**，但值无法修改。|在预处理阶段直接**替换为字面值**，不占用内存。|
|**类型安全**|**有类型**。编译器会进行类型检查，更安全。|**无类型**。只是文本替换，容易导致类型相关的错误。|
|**作用域**|受限于定义它的作用域（如函数、类或文件作用域）。|默认是全局的，从定义位置到文件结束都有效。|


### `typedef` 和 `using`

`typedef` 和 `using` 都用于为类型创建**别名**，以提高代码的可读性和可维护性。
- **`typedef`**:
    - **特点**: 在**编译阶段**处理，有严格的类型检查。
    - **使用场景**:
        - 为复杂类型（如结构体、指针、函数指针）创建简洁的别名。
        - `typedef std::map<std::string, std::vector<int>> StringToIntVectorMap;`
    - **局限性**: `typedef` **不能用于定义模板类型别名**。
        
- **`using`**:
    - **特点**: 在 C++11 引入，与 `typedef` 作用类似，但语法更现代，并且**可以定义模板类型别名**。
    - **使用场景**:
        - 可以替代 `typedef` 的所有功能。
        - **定义模板类型别名**:

            ```cpp
            template <typename T>
            using MyVector = std::vector<T>;
            ```
            这种语法比 `typedef` 结合 `struct` 更简洁直观。