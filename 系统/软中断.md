## 中断是什么？

中断是计算机系统中一种重要的事件处理机制。当硬件设备需要CPU处理某个请求时，会发出一个**中断请求**。操作系统接收到这个请求后，会暂停当前正在执行的程序，转而去执行一个专门的**中断处理程序**来响应这个请求。
- **特点：**
    - **异步机制：** 中断的发生是随机的，不由CPU决定，因此它是一种异步事件处理机制。这使得CPU在等待硬件请求时可以做其他事情，从而大大提高了系统的并发处理能力。
    - **快速响应：** 中断处理程序需要尽可能快地执行完毕，以减少对正常进程调度的影响。
    - **可关闭中断：** 在执行中断处理程序期间，系统可能会临时关闭中断响应。如果处理时间过长，可能会导致其他设备的中断请求无法得到及时响应，甚至丢失。
- **生活类比：**
    - 你正在专注工作（执行进程），外卖小哥打来电话（发出中断请求）。
    - 你挂断电话，暂停工作（响应中断），去拿外卖（执行中断处理程序）。
    - 拿完外卖后，你继续工作（恢复进程）。
---

## [#](https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%B8%AD%E6%96%AD)什么是软中断？

为了解决中断处理时间过长和可能导致中断丢失的问题，Linux系统将中断处理过程分为了**上半部**和**下半部**。软中断就是下半部处理机制中的一种。

- **上半部（硬中断）**
    - **作用：** 快速处理中断，通常会暂时关闭中断响应。它负责处理与硬件紧密相关、时间敏感且耗时短的任务。
    - **特点：** 直接由硬件请求触发，会立即打断CPU正在执行的任务。
- **下半部（软中断）**
    - **作用：** 延迟处理上半部未完成的、耗时较长的任务。
    - **特点：**
        - 由**上半部**（硬中断处理程序）触发。
        - 以**内核线程**的方式执行，通常每个CPU核心都对应一个软中断内核线程，命名为`ksoftirqd/CPU编号`（如`ksoftirqd/0`）。
        - 不会打断CPU正在执行的任务，而是作为普通的内核线程被调度执行。
        - 软中断不仅包括硬中断处理的下半部，还包括一些内核自定义的事件，如内核调度、RCU锁等。
            
- **网络包处理示例：**
    
    1. **硬中断（上半部）：** 网卡接收到网络包后，触发硬件中断。内核中断处理程序（上半部）会立即执行，禁用网卡中断，并触发一个**软中断**。
        
    2. **软中断（下半部）：** 软中断内核线程被唤醒，开始处理耗时的任务，例如从内存中读取网络数据，并按照网络协议栈进行逐层解析和处理，最终将数据交给应用程序。

---

### [#](https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E7%B3%BB%E7%BB%9F%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%B8%AD%E6%96%AD)系统里有哪些软中断？

- `cat /proc/softirqs`：查看不同类型软中断在每个CPU核心上的累计运行次数。
接下来，就来简单的解析下 `/proc/softirqs` 文件的内容，在我服务器上查看到的文件内容如下：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%B8%AD%E6%96%AD/softirqs.png)

- **第一列：** 表示软中断的类型。常见的有：
    - **`NET_RX`**：网络接收中断。 
    - **`NET_TX`**：网络发送中断    
    - **`TIMER`**：定时器中断。
    - **`RCU`**：RCU锁中断。
    - **`SCHED`**：内核调度中断。
- **后续列：** 每个CPU核心对应的该类型软中断的累计次数。正常情况下，同一种类型的中断在不同CPU上的次数应该大致相同。

ps -ef | grep ksoftirqd 查看软中断内核线程
前面提到过，软中断是以内核线程的方式执行的，我们可以用 `ps` 命令可以查看到，下面这个就是在我的服务器上查到软中断内核线程的结果：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%B8%AD%E6%96%AD/ksoftirqd.png)

可以发现，内核线程的名字外面都有有中括号，这说明 ps 无法获取它们的命令行参数，所以一般来说，名字在中括号里的都可以认为是内核线程。

而且，你可以看到有 4 个 `ksoftirqd` 内核线程，这是因为我这台服务器的 CPU 是 4 核心的，每个 CPU 核心都对应着一个内核线程。

---

## [#](https://xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%BD%AF%E4%B8%AD%E6%96%AD-cpu-%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98)如何定位软中断 CPU 使用率过高的问题？

要想知道当前的系统的软中断情况，我们可以使用 `top` 命令查看，下面是一台服务器上的 top 的数据：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%B8%AD%E6%96%AD/top_si.png)
**`top`命令：** 在`top`命令输出中，关注`si`（softirq）这一项，它代表CPU用于处理软中断的百分比。如果`si`值很高，表明系统开销主要来源于软中断。

上图中的黄色部分 `si`，就是 CPU 在软中断上的使用率，而且可以发现，每个 CPU 使用率都不高，两个 CPU 的使用率虽然只有 3% 和 4% 左右，但是都是用在软中断上了。

另外，也可以看到 CPU 使用率最高的进程也是软中断 `ksoftirqd`，因此可以认为此时系统的开销主要来源于软中断。

如果要知道是哪种软中断类型导致的，我们可以使用 `watch -d cat /proc/softirqs` 命令查看每个软中断类型的中断次数的变化速率。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%B8%AD%E6%96%AD/watch.png)

一般对于网络 I/O 比较高的 Web 服务器，`NET_RX` 网络接收中断的变化速率相比其他中断类型快很多。

如果发现 `NET_RX` 网络接收中断次数的变化速率过快，接下来就可以使用 `sar -n DEV` 查看网卡的网络包接收速率情况，然后分析是哪个网卡有大量的网络包进来。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%B8%AD%E6%96%AD/sar_dev.png)

接着，在通过 `tcpdump` 抓包，分析这些包的来源，如果是非法的地址，可以考虑加防火墙，如果是正常流量，则要考虑硬件升级等。