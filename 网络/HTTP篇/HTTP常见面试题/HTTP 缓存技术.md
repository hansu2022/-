###   HTTP 缓存有哪些实现方式？

HTTP 缓存是优化 Web 性能的重要手段之一，它通过将重复的 HTTP 请求的响应数据缓存在本地，避免了不必要的网络通信，从而显著提升了网页加载速度。

HTTP 缓存主要有两种实现方式：**强制缓存**和**协商缓存**。

### [#](https://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98)什么是强制缓存？

强制缓存指的是，当浏览器判断缓存未过期时，会直接从本地读取缓存数据，无需再向服务器发送请求。在这种情况下，开发者工具的 `Size` 一栏会显示 `from disk cache` 或 `from memory cache`，状态码为 `200`。

![](https://cdn.xiaolincoding.com//mysql/other/1cb6bc37597e4af8adfef412bfc57a42.png)

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：

- `Cache-Control`：一个**相对时间**，表示缓存的有效期。
- `Expires`：一个**绝对时间**，表示缓存的过期时间。

如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：
- **首次请求**：浏览器第一次请求某个资源时，服务器在返回该资源的同时，在响应头中添加 `Cache-Control` 字段，并设置一个过期时间。
- **再次请求**：浏览器再次请求该资源时，会先根据请求时间与 `Cache-Control` 中设置的过期时间来判断资源是否过期。
- **判断结果**：
    - **未过期**：浏览器直接使用本地缓存，不向服务器发送请求。
    - **已过期**：浏览器会重新向服务器发送请求，服务器会再次返回资源并更新 `Cache-Control`
### [#](https://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98)什么是协商缓存？

协商缓存是指浏览器在本地缓存过期后，向服务器发送请求，通过协商来判断是否可以使用本地缓存。如果服务器告知缓存有效，浏览器会直接使用本地资源，状态码为 **`304 Not Modified`**；如果资源已更新，则服务器返回新资源，状态码为 **`200 OK`**。
这个过程本质上是**浏览器与服务器进行协商，然后根据协商结果来决定是否使用本地缓存**。
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png)

上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现。

**基于时间：`If-Modified-Since` 和 `Last-Modified`**
- **`Last-Modified`**（响应头）：表示资源在服务器上的最后修改时间。
- **`If-Modified-Since`**（请求头）：当浏览器本地缓存过期后，再次请求时会带上这个字段，其值为上次响应中的 `Last-Modified` 时间。
- **工作原理**：服务器接收到请求后，会将 `If-Modified-Since` 的时间与当前资源的最新修改时间进行对比。
    - 如果服务器上的资源**没有更新**（即修改时间相同或更早），则返回 `304 Not Modified`。
    - 如果服务器上的资源**已更新**（即修改时间更晚），则返回 `200 OK` 并发送新资源。

**基于唯一标识：`If-None-Match` 和 `ETag`**
- **`ETag`**（响应头）：是服务器为每个资源生成的**唯一标识**，通常是一个哈希值。
- **`If-None-Match`**（请求头）：当本地缓存过期后，浏览器再次请求时会带上这个字段，其值为上次响应中的 `ETag` 值。
- **工作原理**：服务器接收到请求后，将 `If-None-Match` 的值与当前资源的 `ETag` 进行比较。
    - 如果**标识一致**，说明资源没有变化，返回 `304 Not Modified`。
    - 如果**标识不一致**，说明资源已更新，返回 `200 OK` 并发送新资源。

#### **为什么 `ETag` 的优先级更高？**
当服务器同时返回 `ETag` 和 `Last-Modified` 时，`ETag` 的优先级更高。这是因为它能更精确地判断资源是否被修改，解决了 `Last-Modified` 的一些局限性：
- **时间不准确**：有时文件内容没有改变，但其最后修改时间可能会被更新（例如，文件被重新保存），导致缓存失效。
- **秒级精度**：`Last-Modified` 的精度是秒，如果一个文件在一秒内被修改了多次，`Last-Modified` 无法感知到这些变化。
- **服务器兼容性**：并非所有服务器都能精确获取文件的最后修改时间。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

下图是强制缓存和协商缓存的工作流程：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png)

当使用 ETag 字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
- 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
    - 如果没有过期，则直接使用本地缓存；
    - 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
- 服务器再次收到请求后，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**：
    - **如果值相等，则返回 304 Not Modified，不会返回资源**；
    - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
- 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。