

### 一、核心区别概览（4 个要点）

| 特性       | HTTP                    | HTTPS                                                  | 记忆点                      |
| -------- | ----------------------- | ------------------------------------------------------ | ------------------------ |
| **安全性**  | **明文传输**，不安全。           | 在 TCP 与 HTTP 之间加入 **SSL/TLS 协议**，报文加密传输，安全。            | **S** for **Secure**（安全） |
| **连接过程** | **简单**。TCP 三次握手后即可传输报文。 | **复杂**。TCP 三次握手后，还需要进行 **SSL/TLS 握手**（密钥交换等），才能传输加密报文。 | 多了一个 **TLS 握手**          |
| **默认端口** | **80**                  | **443**                                                | 端口不同                     |
| **身份验证** | 无需身份验证。                 | 需要向 **CA（证书权威机构）** 申请**数字证书**，保证服务器身份可信。               | 需要 **CA 证书**             |
HTTP 因为是**明文传输**，存在以下 **3** 个安全风险：
1. **窃听风险**：通信内容容易被第三方获取。
2. **篡改风险**：通信内容容易被恶意植入或修改（如植入垃圾广告）。
3. **冒充风险**：服务器身份容易被假冒（如钓鱼网站）。

> HTTPS 是如何解决上面的三个风险的？

HTTPS 通过在 HTTP 与 TCP 层之间加入 **SSL/TLS 协议**，很好地解决了上述风险。

| 安全风险     | HTTPS 解决方式          | 技术原理                                |
| -------- | ------------------- | ----------------------------------- |
| **窃听风险** | **信息加密**（保证**机密性**） | 采用**混合加密**机制。                       |
| **篡改风险** | **校验机制**（保证**完整性**） | 采用**摘要算法**（哈希函数）计算「数据指纹」+ **数字签名**。 |
| **冒充风险** | **身份证书**（保证**可信性**） | 服务器公钥放入**数字证书**中，由 **CA** 保证其可信。    |

_1. 混合加密_

通过**混合加密**的方式可以保证信息的**机密性**，解决了窃听的风险。

![混合加密](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png)

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：

- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。
- **混合加密**：取两者之长，兼顾了**安全**和**性能**。

_2. 摘要算法 + 数字签名_

为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。
- 用于对传输内容计算一个**唯一的哈希值**（即**数据指纹**）。
- **作用**：校验数据是否被篡改。
- **缺陷**：不能防止哈希值本身被中间人替换。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png)

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

- 使用**非对称加密**的 **私钥加密**（对内容的哈希值进行加密），**公钥解密** 的机制。
- **作用**：保证消息的**来源可靠性**（即证明消息确实来源于持有私钥的服务器）。
- 流程：服务端用**私钥**对内容的**哈希值**进行加密（形成数字签名），客户端用**公钥**解密该签名，并比对计算出的哈希值。
流程的不同，意味着目的也不相同：

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png)

私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

_3. 数字证书_

- **问题**：即使有数字签名，**公钥**也可能被中间人伪造并替换。
- **解决方案**：引入 **CA（证书权威机构）** 作为**可信第三方**。 
- **数字证书内容**：包含服务器的**个人信息**、服务器的**公钥**，以及 **CA 对整个证书的数字签名**。
- **验证流程**：
    1. 服务器将**数字证书**发送给客户端。
    2. 客户端使用**内置的 CA 公钥**去验证**证书上的 CA 签名**。
    3. 如果 CA 签名验证成功，则证明**该证书合法**（即服务器身份和公钥是可信的）。
    4. 客户端即可信任证书中包含的**服务器公钥**，进行后续的 TLS 握手和加密通信。
数字证书的工作流程，我也画了一张图，方便大家理解：

![数子证书工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

### [#](https://xiaolincoding.com/network/2_http/http_interview.html#https-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84-%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88)HTTPS 是如何建立连接的？其间交互了什么？

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_rsa.html)和 [ECDHE 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。

基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：

![HTTPS 连接建立过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

TLS 握手涉及四次关键通信，最终双方利用三个随机数生成**会话秘钥**，用于后续的加密通信。

| 步骤        | 发起方 | 消息名称          | 主要交互内容 (包含的随机数)                                                                                                                   | 目标/作用                        |
| --------- | --- | ------------- | --------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- |
| **第 1 次** | 客户端 | `ClientHello` | 1. 客户端支持的 TLS 版本。 2. **Client Random** (随机数)。 3. 客户端支持的**密码套件列表**。                                                                | 客户端发起请求，提供自身能力和第一个随机数。       |
| **第 2 次** | 服务器 | `ServerHello` | 1. 确认使用的 TLS 版本。 2. **Server Random** (随机数)。 3. 确认使用的**密码套件**（如 RSA）。 4. **服务器数字证书**。                                             | 服务器确认参数，提供第二个随机数和**身份证明**。   |
| **第 3 次** | 客户端 | 客户端回应         | 1. 验证证书，**取出服务器公钥**。 2. 使用公钥加密 **pre-master key** (第 3 个随机数)。 3. **算法变更通知**（`Change Cipher Spec`）。 4. **客户端握手结束通知**（`Finished`）。  | 验证服务器身份，并安全地将第三个随机数发送给服务器。   |
| **第 4 次** | 服务器 | 服务器最后回应       | 1. **服务器私钥解密** pre-master key。 2. **双方利用 3 个随机数计算出** **会话秘钥**。 3. **算法变更通知**（`Change Cipher Spec`）。 4. **服务器握手结束通知**（`Finished`）。 | 确认收到所有信息，告知客户端后续将使用会话秘钥加密通信。 |
#### 1. 身份验证与公钥获取（第 2 次通信）
- **服务器**在 `ServerHello` 中发送**数字证书**。
- **客户端**接收证书后，利用**内置的 CA 根证书公钥**验证该证书的**真实性和合法性**。
- 如果验证通过，客户端即可从证书中**安全地取出服务器的公钥**。
#### 2. 会话秘钥的生成（三个随机数）

TLS 握手会话秘钥的生成依赖于三个随机数，从而确保最终秘钥的随机性和安全性：
1. **Client Random**：客户端生成（ClientHello 中发送）。
2. **Server Random**：服务器生成（ServerHello 中发送）。
3. **pre-master key**：客户端生成，并通过**服务器公钥加密**后发送（客户端回应中发送）。

- **RSA 算法下的关键点**：客户端使用**公钥加密** `pre-master key`，只有持有**私钥**的服务器才能解密得到它。
- **最终秘钥**：客户端和服务器**各自**使用这**三个随机数**（Client Random, Server Random, pre-master key）和协商的加密算法**独立计算**出本次通信使用的**会话秘钥**。
#### 3. 算法变更与结束通知（第 3、4 次通信）
- **`Change Cipher Spec`**：通知对方，从这条消息之后，发送的数据都将使用**会话秘钥**进行**加密**。
- **`Finished`**：表示握手阶段结束。这条消息本身也是**用会话秘钥加密**的，并且包含对**之前所有握手数据的摘要**，用于**校验**整个握手过程是否被篡改。

如果想深入学习基于 RSA 算法的 HTTPS 握手过程，可以看这篇，我通过抓包的方式，逐步分析每一个过程：[HTTPS RSA 握手解析(opens new window)](https://xiaolincoding.com/network/2_http/https_rsa.html)
不过，基于 RSA 算法的 HTTPS 存在「前向安全」的问题：如果服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。
为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，关于 ECDHE 握手的过程可以看这篇文章：[HTTPS ECDHE 握手解析(opens new window)](https://xiaolincoding.com/network/2_http/https_ecdhe.html#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0)

📝  **客户端数字证书校验流程**

接下来，详细说一下实际中数字证书签发和验证流程。

如下图图所示，为数字证书签发和验证流程：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png)

CA 签发证书的过程，如上图左边部分：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

但事实上，证书的验证过程中**还存在一个证书信任链的问题**，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/baidu%E8%AF%81%E4%B9%A6.png)
####  证书信任链结构

- **根证书 (Root CA)**：位于信任链顶端，是**自签名证书**，其公钥预置在操作系统或浏览器中，**被客户端天然信任**。
- **中间证书 (Intermediate CA)**：由根证书或上级中间证书签发，用于隔离和保护根证书。
- **服务端证书 (End-Entity Certificate)**：提供给客户端的最终证书，由中间证书签发。
#### 信任链验证步骤（以三级证书为例）
客户端必须沿着证书链**从下往上**，逐级验证到其信任的**根证书**

|步骤|验证对象|验证过程|结果|
|---|---|---|---|
|**1. 获取并检查服务端证书**|baidu.com 证书|客户端收到 baidu.com 证书，发现其签发者不是根证书。|找到其颁发机构（中间证书的名称）。|
|**2. 验证中间证书**|中间证书 (GlobalSign)|客户端向 CA 请求中间证书。发现**中间证书是由根证书签发**。|向上查找**根证书**。|
|**3. 验证根证书**|根证书 (GlobalSign Root CA)|客户端检查本地预置的**根证书清单**，确认 **GlobalSign Root CA** 是否在内。|**如果存在，则该根证书是可信的。**|
|**4. 信任传递（向下验证）**|证书链|客户端使用**根证书公钥**验证**中间证书**的签名。如果验证通过，则信任中间证书。|**可信**。|
|**5. 最终验证**|服务端证书|客户端使用**已信任的中间证书的公钥**，验证 **baidu.com 证书**的签名。|**如果验证通过，则 baidu.com 证书可信。**|

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.png)

操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%B3%BB%E7%BB%9F%E6%A0%B9%E8%AF%81%E4%B9%A6.png)

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png)

最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

**确保根证书的绝对安全**：根证书是整个信任体系的基石。如果根证书的私钥泄露，整个 CA 体系都会被攻破。通过使用中间证书进行日常签发，可以**严格隔离和保护根证书**，即使中间证书私钥泄露，也可以及时撤销，避免全局性问题。

### [#](https://xiaolincoding.com/network/2_http/http_interview.html#https-%E7%9A%84%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84)HTTPS 的应用数据是如何保证完整性的？

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png)

#### TLS 记录协议工作流程

| 步骤           | 行为                                                        | 目的/实现机制                                                             |
| ------------ | --------------------------------------------------------- | ------------------------------------------------------------------- |
| **1. 分割与压缩** | 将 HTTP 消息分割成较短的片段，并进行压缩。                                  | 方便处理。                                                               |
| **2. 附加认证码** | **为每个片段计算并附加** **消息认证码（MAC 值）**。                          | **保证完整性**。MAC 值是通过**哈希算法**（摘要算法）计算得出。为防止重放攻击，计算 MAC 时还加入了**片段的编码**。 |
| **3. 对称加密**  | 将“压缩后的片段”和“MAC 值”**一起**通过**对称加密**（使用握手阶段生成的**会话秘钥**）进行加密。 | **保证机密性**（防窃听）。                                                     |
| **4. 添加报头**  | 在加密数据前加上报头（包含数据类型、版本号、压缩后的长度）。                            | 形成最终的 TLS 记录报文，传递给 TCP 层进行传输。                                       |
**核心机制：** 保证完整性是通过**消息认证码**（MAC 值）实现的，它将内容、编码等信息进行哈希计算，接收方会进行相同的计算并比对，如果 MAC 值不匹配，则数据被视为**遭到篡改**。
记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

如果你想详细了解记录协议是如何分片、压缩、计算 MAC 值、分组加密，可以看这篇：[理解SSL/TLS系列 (四) 记录协议(opens new window)](https://blog.csdn.net/zhanyiwp/article/details/105627799)

### [#](https://xiaolincoding.com/network/2_http/http_interview.html#https-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97)HTTPS 一定安全可靠吗？

之前有读者在字节面试的时候，被问到：**HTTPS 一定安全可靠吗？**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E6%8F%90%E9%97%AE.jpeg)

这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png)

在“中间人攻击”场景中，中间人服务器与客户端、服务端分别建立 TLS 连接，并利用密钥 A 和 B 对数据进行解密、转发和再加密。

|角色|连接对象|使用密钥|攻击成功前提|
|---|---|---|---|
|**客户端**|中间人|对称秘钥 A|**客户端接受**中间人伪造的**非法证书**。|
|**中间人**|服务端|对称秘钥 B|无（服务端不对客户端进行身份校验）。|

从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA.png)

**关键点：** 这种攻击要成功，**前提是客户端必须信任中间人伪造的证书**。
- **情况一：用户手贱。** 浏览器会提示证书非法风险，但用户**执意点击“继续浏览此网站”**，即接受了中间人证书。
- **情况二：电脑中毒。** 电脑被恶意导入了**中间人的根证书**，导致操作系统信任该证书，浏览器便不会弹出安全警告。

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

> 为什么抓包工具能截取 HTTPS 数据？

很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。

对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:

1. 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
2. 中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；

中间人要拿到私钥只能通过如下方式：

1. 去网站服务端拿到私钥；
2. 去CA处拿域名签发私钥；
3. 自己签发证书，切要被浏览器信任；

不用解释，抓包工具只能使用第三种方式取得中间人的身份。

- **实现方式：** 抓包工具在客户端扮演了一个**私有的 CA（认证中心）**。
- **客户端操作：** 使用抓包工具前，用户需在客户端（操作系统/浏览器）中**安装或信任**抓包工具生成的**根证书**。
- **结果：** 客户端信任了抓包工具的根证书后，抓包工具签发的任何证书都会被认为是**合法的**，从而绕过了浏览器的安全警告，成功实现中间人解密。

> 如何避免被中间人抓取数据？

- **保证电脑安全**：防止被病毒入侵和恶意导入伪造的根证书。
- **不访问证书非法的网站**：严格遵守浏览器的安全警告。
- **使用 HTTPS 双向认证（Mutual TLS）**：
    
    - **单向认证（默认）**：客户端验证服务端身份。
    - **双向认证**：**客户端**验证**服务端**身份，同时**服务端**也会验证**客户端**身份。如果服务端发现客户端身份不可信，则会拒绝通信，进一步增强安全性。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png)

如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

## [#](https://xiaolincoding.com/network/2_http/http_interview.html#http-1-1%E3%80%81http-2%E3%80%81http-3-%E6%BC%94%E5%8F%98)HTTP/1.1、HTT