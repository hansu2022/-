![[Pasted image 20250925183552.png]]
#### 缓存
见链接[[HTTP 缓存技术]]

## [#](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-http-%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0)如何减少 HTTP 请求次数？

减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：

- _减少重定向请求次数_；
- _合并请求_；
- _延迟发送请求_；

### [#](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%87%8F%E5%B0%91%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0)减少重定向请求次数

我们先来看看什么是**重定向请求**？

- **重定向**（Redirect）是指服务器告知客户端所需资源已移至新地址（URL）。客户端需要根据 **`Location`** 头部和 **`3xx`** 状态码再次发起新的请求。
- 重定向次数过多会增加客户端与服务器之间的**消息传递次数**，从而降低性能。

服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.png)

如果**重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了**，如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png)

而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.png)

除了 `302` 重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E9%87%8D%E5%AE%9A%E5%90%91%E5%93%8D%E5%BA%94%E7%A0%81.png)

- **服务器配置优化（代理服务器处理）：**
    - 将重定向的工作交给**代理服务器**完成，可以减少客户端与代理服务器之间的消息传递次数。
        
    - 如果代理服务器知晓重定向规则，可以直接修改请求 URL 后再转发给源服务器，进一步减少消息传递次数。
- **利用缓存的重定向码：**
    - 使用 **`301` (永久移动)** 或 **`308` (永久重定向)** 响应码。
    - 这些状态码会告诉客户端将重定向规则**缓存到本地**，以后客户端就会**自动使用新的 URL** 访问资源，从根本上消除了后续的重定向请求。

### [#](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82)合并请求

**核心思想：** 将多个小资源的请求合并成一个大的请求，以减少请求数、HTTP 头部冗余和 TCP 连接数。

- **减少头部冗余：** 减少重复发送 HTTP 头部。
- **减少 TCP 连接数：** 由于浏览器一般会并发建立 5-6 个 TCP 连接来防止 HTTP/1.1 的队头阻塞（非管道模式），合并请求可以减少 TCP 连接，从而节省**TCP 握手**和**慢启动**的耗时。

#### 具体合并方式：

|方式|机制|效果|带来的问题|
|---|---|---|---|
|**CSS Image Sprites**|将多个小图片、小图标合并成一个**大图片**，通过 CSS 定位来显示所需部分。|浏览器只需一次请求获取大图。|图像更新困难，单个小图更新需重新下载整个大图。|
|**资源打包 (Bundling)**|使用 **`webpack`** 等打包工具将多个 **JS**、**CSS** 文件合并打包成一个或少数几个大文件。|减少脚本和样式文件的请求次数。|资源更新粒度过大，某小块代码变化需重新下载大文件。|
|**Base64 编码内嵌**|将图片的二进制数据用 **`Base64`** 编码后，作为 URL 嵌入到 **HTML/CSS 文件**中。|图片跟随 HTML 文件一起发送，客户端直接解码显示，无需发起额外的图片请求。|增大了 HTML/CSS 文件的大小，不适合大图。|

### [#](https://xiaolincoding.com/network/2_http/http_optimize.html#%E5%BB%B6%E8%BF%9F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82)延迟发送请求

**核心思想：** 采用“按需获取”的方式，只在需要时才发送 HTTP 请求，避免一次性获取所有资源。

#### 机制
- **按需获取 (Lazy Loading)：** 只获取当前用户**可见页面**或**当前交互所需**的资源。
- **举例：** 在请求网页时，只加载首屏内容所需的资源。当用户**向下滑动页面**或执行特定操作时，再延迟发送请求获取接下来的资源。

#### 效益：
- 减少了**第一时间**（初始页面加载时）的 HTTP 请求次数。
- 加快了页面的**首次加载时间**（Time to Interactive, TTI），提升了用户体验。

### 减少响应数据大小

减少 HTTP 响应数据的大小是提高网络传输效率的关键手段。主要通过对服务器返回的资源进行**压缩**来实现，压缩分为**无损压缩**和**有损压缩**两种。

### 1. 无损压缩 (Lossless Compression)

定义： 压缩后信息不被破坏，可以完全恢复到压缩前的原样。
适用场景： 文本文件、代码文件（HTML, CSS, JavaScript）、可执行程序。
#### 机制
1. **代码语法压缩：** 去除代码文件（如 JS, CSS）中多余的**换行符**、**空格**等，这些符号是为了方便程序员阅读，但机器执行时不需要。
2. **统计模型压缩：** 对原始资源建立统计模型，利用如**霍夫曼编码**的算法，将**常出现**的数据用**较短**的二进制比特序列表示，将**不常出现**的数据用**较长**的二进制比特序列表示。

#### 核心实践：
- **客户端协商：** 客户端通过 HTTP 请求头部的 **`Accept-Encoding`** 字段告知服务器支持的压缩算法（如 `gzip`, `deflate`, `br`）。
```http
Accept-Encoding: gzip, deflate, br
```
- **服务器响应：** 服务器选择一种支持的算法压缩资源，并通过响应头部的 **`Content-Encoding`** 字段告知客户端使用的压缩算法。
```http
Content-Encoding: gzip
```
- **算法选择：** 相比于常见的 **`gzip`** 算法，Google 推出的 **`Brotli` (`br`)** 算法通常具有更高的压缩效率，服务器应优先考虑使用。
    

### 2. 有损压缩 (Lossy Compression)

定义： 压缩后解压的数据会与原始数据有所不同，但非常接近。通过舍弃次要数据、牺牲部分质量来减少数据量和提高压缩比。
适用场景： 多媒体数据，如图片、音频、视频。
#### 图片压缩：
- **WebP 格式：** Google 推出的 WebP 格式图片在**相同质量**下，文件大小通常比常见的 Png 格式图片更小。对于大量图片的网站，使用 WebP 可以**大幅度提升**网络传输性能。
- **客户端协商：** 客户端可以通过 HTTP 请求头部 **`Accept`** 字段中的 **`q` 质量因子**来告诉服务器期望的资源质量。
```http
Accept: audio/*; q=0.2, audio/basic
```

#### 音视频压缩：

- **时序增量编码：** 音视频数据具有时序连续性，连续的帧之间变化往往很小。
    
- **机制：** 只需在一个**静态的关键帧**的基础上，使用**增量数据**来表达后续的变化帧，从而减少了大量重复数据。
    
- **常见编码格式：**
    
    - **视频：** H264、H265 等。
        
    - **音频：** AAC、AC3 等。
        

---

## 📚 HTTP/1.1 性能优化思路总结

根据您提供的所有信息，HTTP/1.1 协议的性能优化思路可以归纳为以下三个核心方面：

### 核心思路一：利用缓存 (避免请求)

- **机制：** 客户端收到响应后将其缓存。
    
    - **强缓存：** 缓存未过期时，直接使用本地缓存，**不发送** HTTP 请求。
        
    - **协商缓存：** 缓存过期时，客户端带上资源摘要（如 ETag 或 Last-Modified）发送请求。若资源未变，服务器返回 **`304 Not Modified`** 响应（**不带包体**），客户端使用本地缓存。
        

### 核心思路二：减少请求次数 (降低开销)

- **重定向优化：** 将客户端的重定向工作交给**代理服务器**处理，或使用可缓存的重定向码（`301`/`308`）以避免多次重定向请求。
    
- **合并请求：**
    
    - **资源合并：** 使用 **CSS Image Sprites** 或 **打包工具**（如 Webpack）将多个小资源合并成一个大资源传输。
        
    - **内嵌资源：** 使用 **Base64** 编码将小图片内嵌到 HTML 或 CSS 中。
        
- **延迟请求：** 采用**按需获取**（懒加载）的方式，只获取当前用户可见/所需资源，延迟发送不紧急的请求。
    

### 核心思路三：压缩响应数据 (降低传输量)

- **无损压缩：** 针对文本类文件，使用 **`gzip`** 或效率更高的 **`Brotli` (`br`)** 算法压缩。
    
- **有损压缩：** 针对图片、音视频等多媒体数据，使用 **WebP** 格式或高效的音视频编码（如 H265）来压缩数据。
