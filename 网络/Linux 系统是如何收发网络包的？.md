## Linux 接收网络包的流程

### **1. 网卡接收网络包**

网络接口卡（NIC），也就是我们常说的网卡，是负责网络通信的硬件设备。当一个网络包到达网卡时，它不会直接进入 CPU。
- **DMA（直接内存访问）技术**: 网卡利用 **DMA 技术**，将接收到的网络包直接写入到内存中的指定区域。这个内存区域被称为 **Ring Buffer（环形缓冲区）**。这样做的目的是避免 CPU 频繁地参与数据搬运工作，从而提高效率。
- **触发中断**: 当数据包成功写入 Ring Buffer 后，网卡会通过触发 **硬件中断** 的方式通知 CPU，告诉它有新的数据包已经准备好。
### **2. 硬件中断处理**

在早期的 Linux 内核中，每收到一个网络包就会触发一次中断，这在网络负载较高时会导致大量的 CPU 时间被用于处理中断，严重影响系统性能。为了解决这个问题，Linux 内核在 2.6 版本后引入了 **NAPI（New API）机制**。

**NAPI 机制** 是一种混合了“中断”和“轮询”的数据接收方式，其核心思想是：

> **通过一次中断来唤醒数据接收服务，然后通过轮询的方式批量处理后续数据包，直到 Ring Buffer 为空。**

具体流程如下：

1. **CPU 收到硬件中断**: 当网卡触发中断时，CPU 会暂停当前任务，转而执行预先注册好的 **硬件中断处理函数**。
    
2. **屏蔽中断**: 硬件中断处理函数会立即**暂时屏蔽**网卡的中断。这意味着在接下来的处理过程中，即使有新的数据包到达，网卡也不会再次向 CPU 发出中断请求。
    
3. **发起软中断**: 紧接着，硬件中断处理函数会**发起一个软中断**。
    
4. **恢复中断**: 最后，恢复刚才屏蔽的中断。

至此，硬件中断处理函数的工作就结束了。它的主要任务是快速响应、屏蔽中断并调度后续处理，将耗时的数据处理工作交给软中断来完成。

### **3. 软中断处理**

软中断是 Linux 内核的一种异步处理机制，它的处理任务交由专门的内核线程 **`ksoftirqd`** 来负责。

1. **`ksoftirqd` 线程被唤醒**: 当硬件中断处理函数发起软中断后，`ksoftirqd` 线程就会被唤醒。
    
2. **轮询处理**: `ksoftirqd` 线程会开始**轮询**，从 Ring Buffer 中批量获取网络包。
    
3. **封装数据**: 内核会为每个网络包创建一个名为 `sk_buff` 的数据结构。`sk_buff` 是 Linux 内核中一个非常重要的数据结构，它贯穿整个网络协议栈，用于表示和管理网络数据包。
    
4. **递交给网络协议栈**: `ksoftirqd` 线程会将封装好的 `sk_buff` 结构体，按照其协议类型（例如 IPv4、IPv6）递交给上层的网络协议栈进行进一步处理，如解封装、路由和交付到相应的应用程序。
### **2.进入网络协议栈**

`ksoftirqd` 线程被唤醒后，会从 Ring Buffer 中取出数据包，并封装成 `sk_buff` 结构体，正式开始协议栈的处理流程。
#### **网络接口层（链路层）**

- **校验合法性**: 在这一层，内核会检查数据帧的合法性。如果数据帧不合法，比如校验和错误，则直接丢弃。
- **解析协议类型**: 如果数据帧合法，内核会解析帧头，找出**上层协议类型**（如 IPv4 或 IPv6），然后去掉帧头和帧尾。
- **传递**: 处理完后，将数据包传递给上层的网络层。
#### **网络层**
- **取出 IP 包**: 网络层会取出 IP 包，并进行一系列判断：
    - **下一步走向**: 确认这个网络包是需要**本地处理**（即发送给本机应用程序），还是需要**转发**出去。
    - **目的 IP**: 如果网络包的目的 IP 地址不是本机，它会被转发到其他主机。
- **解析上层协议**: 如果确认网络包是发给本机的，内核会解析 IP 头，判断**上一层协议类型**（如 TCP 或 UDP），然后去掉 IP 头。
    
- **传递**: 将处理后的数据包传递给传输层。
#### **传输层**

- **定位 Socket**: 传输层会取出 TCP 或 UDP 的头部，并根据**四元组**（源 IP、源端口、目的 IP、目的端口）来唯一识别一个连接。
- **数据放入接收缓冲区**: 根据四元组找到对应的 **Socket**，然后将数据包的数据部分放到该 Socket 的**接收缓冲区**中。

### **3. 应用层读取数据**

- **调用接口**: 当数据进入 Socket 接收缓冲区后，应用程序通过调用 `read()` 或 `recv()` 等 **Socket 接口**，将数据从内核态的 Socket 缓冲区中**拷贝**到用户态的应用程序缓冲区。
- **唤醒进程**: 数据拷贝完成后，内核会唤醒正在等待数据的用户进程。至此，一个网络包的完整接收流程就结束了。

至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。
![[Pasted image 20250922174641.png]]

## **Linux 网络包发送流程详解**

### **1. 应用程序发送数据**

- **系统调用**: 应用程序调用 `send()` 或 `write()` 等 Socket 接口发送数据，这会触发一个**系统调用**，使程序从用户态切换到内核态。
    
- **创建 sk_buff**: 内核会为待发送的数据申请一个 **`sk_buff` 内存**。这个结构体是 Linux 内核网络协议栈中所有数据包的统一描述结构。
    
- **数据拷贝**: 内核将应用程序的数据从用户态缓冲区**拷贝**到新创建的 `sk_buff` 内存中，并将其加入到 Socket 的**发送缓冲区**。
### **2. 协议栈逐层封装**

接下来，网络协议栈会从 Socket 发送缓冲区中取出 `sk_buff`，并按照 **TCP/IP 协议栈**自上而下逐层处理和封装。
#### **传输层 (TCP/UDP)**
- **处理 TCP 重传**: 如果使用 **TCP** 协议，内核会先创建一个原始 `sk_buff` 的**副本**。这是因为 TCP 支持**丢包重传**，在收到对方的 ACK 确认前，原始的 `sk_buff` 不能被释放。真正交给网卡发送的是这个副本，而原始 `sk_buff` 则留在内存中等待 ACK。

- **填充协议头**: 协议栈会根据当前层次，在 `sk_buff` 的数据缓存区**预留空间**并填充相应的协议头。`sk_buff` 的核心设计在于，它**只用一个结构体来描述所有层的数据包**，避免了跨层传递数据时的多次内存拷贝。
    
    - **`sk_buff->data` 指针**: 通过调整 `sk_buff` 中 `data` 指针的位置，可以实现数据的“封装”和“解封装”。
        
        - **发送时**: 协议栈通过**减少** `sk_buff->data` 的值，在数据缓存区的头部**增加**各层协议头（如下图 (a) 到 (f) 所示）。
            
        - **接收时**: 协议栈则**增加** `sk_buff->data` 的值，来逐步**剥离**各层协议头。
![[Pasted image 20250922175214.png]]

#### **网络层 (IP)**

- **路由选择**: 内核会根据数据包的目的 IP 地址，通过**路由表**来决定“下一跳”的 IP 地址。
    
- **填充 IP 头**: 在 `sk_buff` 头部预留的空间中，填充 IP 协议头。
    
- **Netfilter 过滤**: 数据包会经过 Netfilter 框架的过滤规则检查。
    
- **数据包分片**: 如果数据包的大小超过了接口的 **MTU**（最大传输单元），内核会进行**分片**处理。

#### **网络接口层 (以太网)**

- **获取 MAC 地址**: 内核通过 **ARP 协议**，将“下一跳”的 IP 地址解析为对应的 **MAC 地址**。
    
- **填充帧头/尾**: 在 `sk_buff` 头部填充以太网帧头（包含源/目的 MAC 地址），并添加帧尾校验码。
    
- **放入发送队列**: 处理好的 `sk_buff` 会被放入网卡驱动程序的**发送队列**中。
    

### **3. 网卡发送与内存释放**

- **触发软中断**: 协议栈完成所有封装后，会触发一个**软中断**，通知网卡驱动程序有数据需要发送。
    
- **驱动程序处理**:
    
    1. 网卡驱动从发送队列中取出 `sk_buff`。
        
    2. 将 `sk_buff` 挂入 **Ring Buffer**。
        
    3. 将 `sk_buff` 数据映射到网卡可访问的 **DMA 内存区域**。
        
    4. 最后，触发网卡进行**实际的数据发送**。
        
- **释放内存**:
    
    - **硬件中断**: 当网卡完成数据发送后，会触发**硬件中断**，通知 CPU。网卡中断处理程序会**清理 Ring Buffer**，并释放用于发送的 `sk_buff` 副本内存。
        
    - **TCP ACK 确认**: 对于 TCP 协议，只有当传输层收到对方的 **ACK 确认应答**后，才会**真正释放**在等待重传的原始 `sk_buff` 内存。
### **网络包发送过程中的内存拷贝**

在 Linux 系统中发送网络数据包时，主要会涉及以下几次内存拷贝操作：

#### **1. 应用层数据到内核态的拷贝**

- **操作**：这是整个流程的起点。当应用程序调用 `send()` 等系统调用发送数据时，会从用户态切换到内核态。
    
- **目的**：内核会申请一块内核态的 **`sk_buff` 内存**，然后将用户态缓冲区中的待发送数据**拷贝**到这块新申请的内存中，并将其加入到 Socket 的发送缓冲区。
#### **2. TCP 重传副本的拷贝**

- **操作**：仅在使用 **TCP 协议**时发生。在数据包从传输层进入网络层之前，内核会为原始的 `sk_buff` **创建一个副本**。
    
- **目的**：TCP 是一种可靠的传输协议。为了处理丢包重传，原始的 `sk_buff` 需要保留在内存中，直到收到对方的 ACK 确认。真正被送往网络层并最终发送出去的是这个 `sk_buff` 副本。当副本发送完毕后，它会被立即释放。只有当收到 ACK 后，原始的 `sk_buff` 才会被释放。
#### **3. IP 分片带来的拷贝**

- **操作**：仅在数据包大小超过 **MTU**（最大传输单元）时发生。
    
- **目的**：当 IP 层发现 `sk_buff` 的大小超过了 MTU，它会申请额外的 `sk_buff` 内存，并将原始的 `sk_buff` 数据**拷贝**并分割成多个小的 `sk_buff`，每个小 `sk_buff` 都会被独立发送。