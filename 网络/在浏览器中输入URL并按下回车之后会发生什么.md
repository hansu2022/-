![[Pasted image 20250920201120.png]]
![[Pasted image 20250920211707.png]]
### 简要回答
#### **1. 浏览器处理请求**

1. **解析 URL：** 浏览器首先会对你输入的URL进行解析，识别出协议（如`http`）、域名（如`www.server.com`）、端口号和路径等信息。
    
2. **构造 HTTP 请求报文：** 根据解析结果，浏览器会生成一个完整的HTTP请求报文，包含请求方法（如`GET`）、路径和协议版本等。
---
#### **2. 域名解析 (DNS)**

- **目的：** 浏览器需要将域名转换成服务器的**IP地址**。这个过程由DNS（域名系统）完成。
    
- **查询顺序：** 浏览器会按以下顺序查找IP地址，以提高效率：
    
    1. **浏览器缓存** → **操作系统缓存** → **本地 `hosts` 文件**。
        
    2. 如果以上都找不到，会向**本地DNS服务器**发起查询。
- **DNS 递归查询：** 本地DNS服务器会向根域名服务器、顶级域名服务器和权威域名服务器进行**递归查询**，直到获取到域名对应的IP地址，并返回给浏览器。

---
#### **3. 协议栈处理与数据封装**  （3和4若无追问可简单说
1、目标 IP 发起三次握手（三次握手建立 TCP 连接）
 若是 HTTPS，还需进行 TLS 握手，协商加密算法、验证证书
2、客户端发送 HTTP 请求报文：
）

当获取到IP地址后，浏览器将数据传输任务交给操作系统的**协议栈**。这是一个自上而下的封装过程：
1. **应用层 (HTTP)：** 浏览器将HTTP请求报文交给传输层。
2. **传输层 (TCP)：**
    - **三次握手：** TCP会首先与服务器进行**三次握手**，建立可靠的连接。
        
    - **数据分段：** 如果HTTP请求数据过大，TCP会根据**MSS**（最大报文段长度）将数据分割成多个数据段。
        
    - **TCP报文封装：** TCP为每个数据段加上**TCP头部**（包含源/目标端口号、序号、确认号等），确保数据可靠、有序地传输。
        
3. **网络层 (IP)：**
    
    - **IP报文封装：** IP协议为每个TCP报文加上**IP头部**（包含源/目标IP地址、协议号等），以实现跨网络的寻址。
        
    - **路由选择：** IP协议会查询**路由表**，根据目标IP地址确定数据包应该从哪个网卡发送出去，并找到**下一跳路由器的IP地址**。
        
4. **网络接口层 (MAC)：**
    
    - **MAC地址解析：** 协议栈会根据路由表得到的下一跳IP地址，通过**ARP协议**来获取对应的**MAC地址**。
        
    - **数据帧封装：** 协议栈将IP数据包封装成**数据帧**，加上**MAC头部**（包含源/目标MAC地址）和**FCS**（帧校验序列）。
        
5. **物理层：** 网卡将数据帧中的二进制数据转换成**电信号**，通过网线发送到网络中。
    

---

#### **4. 网络传输**

- **交换机转发：** 数据帧在局域网内通过**交换机**进行转发。交换机工作在MAC层，它会根据数据帧的**目标MAC地址**查询**MAC地址表**，将数据精确地发送到对应的端口。
    
- **路由器转发：** 当数据包需要跨越子网时，**路由器**会接收它。路由器工作在IP层，它会剥离旧的MAC头部，然后根据**路由表**重新确定下一跳，并封装上新的MAC头部，再将数据包发送出去。
    
- **重复与到达：** 这个过程会不断重复，直到数据包到达目标服务器所在网络。
    

---

#### **5. 服务器处理请求与返回响应**

1. **服务器层层解封装：** 数据包到达服务器后，服务器的协议栈会进行反向操作：从物理层开始，层层剥离MAC、IP和TCP头部，最终将HTTP请求报文交给**Web服务器**。
    
2. **服务器处理：** Web服务器（如Nginx）将请求转发给**应用服务器**（如Java、Python等），应用服务器执行业务逻辑（如查询数据库），并构造HTTP响应报文。
    
3. **返回响应：** 服务器将HTML、CSS等资源封装在HTTP响应中，并再次通过TCP/IP协议栈，层层封装数据，**以相反的路径**返回给客户端浏览器。
    

---

#### **6. 浏览器渲染页面**

客户端收到响应数据包后，浏览器会进行层层解封装，获取到HTTP响应报文，然后开始渲染页面：

1. **构建 DOM 树：** 解析HTML代码，构建DOM树。
    
2. **构建 CSSOM 树：** 解析CSS样式，构建CSSOM树。
    
3. **合成 Render Tree：** 将DOM树和CSSOM树结合，生成渲染树。
    
4. **布局 (Layout)：** 计算渲染树中每个元素的精确位置和大小。
    
5. **绘制 (Paint)：** 将计算好的元素绘制到屏幕上。
    
6. **合成 (Compositing)：** 将所有图层合并，最终呈现出完整的页面。
### 1 解析URL
- **解析 URL**：这是第一步。浏览器会解析你输入的 URL，从中提取出协议（如 `http`）、域名（如 `www.server.com`）、端口号（默认为 `80`）、文件路径等信息。
- **生成 HTTP 请求**：根据解析出的信息，浏览器会构造一个 HTTP 请求报文。这个报文包含请求方法（如 `GET`）、请求路径和版本号等信息
首先浏览器做的第一步工作就是要对 `URL` 进行解析，从而生成发送给 `Web` 服务器的请求信息。
![[Pasted image 20250920201150.png]]
对URL进行解析之后，浏览器确定了Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。
![[Pasted image 20250920201218.png]]

一个孤单HTTP数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知
道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？“。充满各种疑问的它，没有停滞不
前，依然踏上了征途！

### 2 DNS
**目的**：HTTP 请求报文需要发送给服务器，但发送时必须知道服务器的 **IP 地址**。而我们输入的是域名，所以需要将域名解析成 IP 地址。这个任务由 DNS（域名系统）服务器完成。
**查询顺序**：为了提高效率，浏览器会按以下顺序查找 IP 地址：
1. **浏览器缓存**：首先检查浏览器自身是否有该域名的缓存。
2. **操作系统缓存**：如果浏览器没有，会向操作系统查询，操作系统会检查自己的缓存。
3. **hosts 文件**：如果操作系统缓存也没有，会检查本地的 hosts 文件。
4. **本地 DNS 服务器**：如果以上都没有，才会向你电脑网络设置中配置的本地 DNS 服务器发起请求。
**DNS 递归查询（本地 DNS 服务器）**：
5. 本地 DNS 服务器收到请求后，会先检查自己的缓存，如果找不到，它会向**根域名服务器**发起请求。
6. 根域名服务器不直接解析，它只告诉本地 DNS 服务器哪个**顶级域名服务器**（如 `.com`）负责这个域名。
7. 本地 DNS 服务器再向 `.com` 顶级域名服务器请求。
8. 顶级域名服务器会告诉本地 DNS 服务器哪个**权威域名服务器**负责 `server.com` 这个域名。
9. 本地 DNS 服务器最后向 `server.com` 的权威域名服务器发起请求。
10. 权威域名服务器查询到对应的 IP 地址后，返回给本地 DNS 服务器。
11. 本地 DNS 服务器将 IP 地址返回给客户端（你的浏览器），同时将此映射关系缓存起来，以便下次快速响应。
![[Pasted image 20250920201326.png]]
域名解析的工作流程
![[Pasted image 20250920201354.png]]整个 DNS 解析过程就像问路：本地 DNS 服务器就像你本人，它先问根服务器这个大方向，根服务器指路给顶级域名服务器，顶级域名服务器再指路给权威域名服务器，最终权威服务器给出确切的地址。这个过程只会指路，不会带路。
数据包表示："DNS老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需
要谁的帮助呢？"
### 3 协议栈
当浏览器通过 DNS 获取到服务器的 IP 地址后，接下来的数据传输工作就交给了操作系统的**协议栈**协议栈是一个分层结构，每一层负责不同的工作，并向下层委托任务
![[Pasted image 20250920202642.png]]
### **协议栈的层次结构**
- **应用层（浏览器）**：这是最顶层，通过调用 **Socket 库**来委托协议栈工作。它将 HTTP 请求数据交给下一层。
- **传输层（TCP/UDP）**：这一层负责数据的收发。
    - **TCP**（传输控制协议）：负责**可靠**的数据传输，确保数据包不丢失、不乱序。
    - **UDP**（用户数据报协议）：提供**无连接**的、快速的数据传输，不保证可靠性。  
- **网络层（IP）**：这一层是协议栈的核心。
    - **IP 协议**：负责将数据切分成一个个**网络包**，并控制这些网络包的收发。它使用 **IP 地址**来确定数据包的传输路径。
    - **ICMP 协议**：**IP 协议**的辅助协议，用于报告网络包在传输过程中遇到的错误（如目标不可达）和控制信息。
    - **ARP 协议**：负责根据 **IP 地址**查询对应的 **MAC 地址**，为下一层的数据传输做准备。
- **网络接口层（网卡驱动/网卡）**：这是最底层，负责实际的数据收发。
    - **网卡驱动程序**：控制**网卡**硬件。
    - **网卡**：将网络包转换成可以在网线中传输的**电信号**，并负责发送和接收这些信号。
从上到下，每一层都会给数据包加上自己的**头部信息**。应用层的数据包交给 TCP，TCP 加上头部后交给 IP，IP 再加上头部后交给网卡驱动，最终由网卡发送到网络中。这个过程就像层层包装，最终形成一个完整的、可以在网络中传输的数据包。
数据包看了这份指南表示："原来我需要那么多大佬的协助啊，那我先去找找**TCP** 大佬！"

### 4 TCP
**TCP**（传输控制协议）是 HTTP 协议的底层传输基础，它提供**可靠的**、**面向连接的**数据传输服务。
![[Pasted image 20250920203159.png]]
一个 TCP 报文头部包含了多个重要字段，以实现其核心功能：
- **源/目标端口号**：用于标识发送和接收数据的应用程序。
- **序号**：解决数据包**乱序**问题，确保数据按正确的顺序重组。
- **确认号**：用于确认已收到的数据，解决数据**丢包**问题。如果发送方没有收到确认，就会重传数据。
- **状态位**：用于管理连接状态。常见的有：
    - **SYN**：用于发起连接。
    - **ACK**：用于确认收到数据或连接请求。
    - **FIN**：用于结束连接。
- **窗口大小**：用于**流量控制**。通信双方各自声明一个窗口大小，告诉对方自己还能接收多少数据，避免发送方发送过快导致接收方处理不过来。
- **拥塞控制**：TCP 能够根据网络状况（如拥堵程度）动态调整发送速率，从而避免网络拥塞。

![[Pasted image 20250920203418.png]]

TCP 是一种面向连接的协议，在传输数据前必须先建立连接。**三次握手**就是建立连接的过程，目的是确保通信双方都具备发送和接收数据的能力。
- **第一次握手**：客户端向服务器发送 **SYN**（同步序列号）报文，进入 `SYN-SENT` 状态。
- **第二次握手**：服务器收到 SYN 后，返回一个 **SYN + ACK**（确认）报文，进入 `SYN-RCVD` 状态。
- **第三次握手**：客户端收到 SYN + ACK 后，发送一个 **ACK** 报文，双方都进入 `ESTABLISHED`（已建立连接）状态。

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。
![[Pasted image 20250920203441.png]]
### **TCP 数据分段**
- **MTU**（最大传输单元）：一个网络包的最大长度，通常为 1500 字节。
- **MSS**（最大报文段长度）：TCP 数据包所能容纳的最大数据量，等于 **MTU - IP 头部 - TCP 头部**。
- 当 HTTP 请求数据过大时，TCP 会将数据按照 **MSS** 的大小进行**分段**。每个数据段都会被加上 TCP 头部，然后交给 IP 模块处理。
![[Pasted image 20250920203452.png]]
![[Pasted image 20250920203601.png]]

### TCP 报文生成
TCP 协议里面会有两个端口，一个是浏览器监听的端口(通常是随机生成的)，
一个是Web 服务器监听的端口（HTTP 默认端口号是**80**，HTTPS 默认端口号是**443**）。
在双方建立了连接后，TCP 报文中的数据部分会存放 **HTTP 头部和数据**，组装好TCP 报文之后，就需交给下面的网络层处理。
至此，网络包的报文如下图。TCP 头部 -> HTTP 数据。
![[Pasted image 20250920203613.png]]
此时，遇上了TCP 的数据包激动表示："太好了，碰到了可靠传输的TCP 传输，它给我加上TCP 头
部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？＂

### 5、IP
当 TCP 协议准备好数据后，它会委托 IP 协议将数据封装成**网络包**，并发送给通信对象。IP 协议是网络层最核心的协议。
![[Pasted image 20250920204017.png]]
- **源地址 IP**：即客户端的 IP 地址。
- **目标地址 IP**：通过 DNS 解析得到的 Web 服务器的 IP 地址。
- **协议号**：这个字段告诉接收方，IP 包的数据部分是哪种协议的报文。例如，如果封装的是 **TCP** 报文，协议号就会被设置为 `06`（十六进制）

### **IP 地址的选择**

当你的设备有多个网卡（比如既有有线连接又有 Wi-Fi），就会有多个 IP 地址。IP 协议需要决定使用哪个 IP 地址作为源地址来发送网络包。

这个选择过程依据的是**路由表**。
### **路由表与路由选择**

- **作用**：路由表存储了一系列规则，决定网络包应该从哪个网卡发送出去，以及下一个目的地是哪里。
- **查看命令**：在 Linux 中，你可以使用 `route -n` 命令来查看路由表。
- **匹配规则**：当 IP 协议收到一个要发送的数据包时，它会拿着**目标 IP 地址**，从路由表的第一条规则开始匹配，直到找到最合适的规则。
    - **匹配过程**：将目标 IP 地址与每一条规则的子网掩码（Genmask）进行按位与运算，然后将结果与该规则的目标地址（Destination）进行比较。
    - **匹配成功**：如果两者一致，则匹配成功。IP 协议就会选择该规则指定的网卡（如 `eth1`）作为源地址来发送数据包。
        
    - **默认网关**：如果所有规则都匹配失败，IP 协议会选择**默认网关**。默认网关的规则通常用 `0.0.0.0` 作为目标地址和子网掩码。数据包会被发送给这个网关（路由器），由路由器来决定接下来的传输路径。
![[Pasted image 20250920204326.png]]
IP 报文生成
IP 头部 -> TCP 头部 -> HTTP 数据。
![[Pasted image 20250920204051.png]]
此时，加上了IP 头部的数据包表示：“有IP 大佬给我指路了，感谢IP 层给我加上了IP 包头，让我
有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪
呢？

### 6、MAC
当 IP 协议封装好网络包后，它会交给**网络接口层**。网络接口层在 IP 头部前面加上 **MAC 头部**，最终形成一个可以在局域网中传输的**数据帧**。
![[Pasted image 20250920205300.png]]在MAC包头里需要发送方MAC地址和接收方目标MAC地址，用于两点之间的传输。
一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：
0800：IP 协议
0806：ARP 协议
### **MAC 报文头部**
- **接收方 MAC 地址**：用于标识**接收端的网卡**。
- **发送方 MAC 地址**：用于标识**发送端的网卡**。这个地址在网卡出厂时就被写入了 ROM，可以直接读取。
- **协议类型**：该字段指示 MAC 头部后面跟着的是什么协议的报文。
    - **`0800`**：表示后面是 **IP 协议**的报文。
    - **`0806`**：表示后面是 **ARP 协议**的报文。
### **确定接收方 MAC 地址**

确定接收方 MAC 地址是一个关键步骤：

1. **查询路由表**：首先，根据**目标 IP 地址**查询**路由表**。
2. **找到网关 IP**：路由表会指示数据包应该发往哪个**网关**（Gateway）的 IP 地址。
3. **使用 ARP 协议**：如果本地设备的 ARP 缓存中没有该网关 IP 对应的 MAC 地址，就需要使用 **ARP 协议**来获取。设备会广播一个 ARP 请求，询问谁是这个 IP 地址的设备？请告诉我你的 MAC 地址。网关收到请求后，会返回自己的 MAC 地址。
具体可见[[ARP协议]]
在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 ARP 缓存的内容。
![[Pasted image 20250920205414.png]]
![[Pasted image 20250920205421.png]]
此时，加上了MAC头部的数据包万分感谢，说道："感谢MAC大佬，我知道我下一步要去哪了！
我现在有很多头部兄弟，相信我可以到达最终的目的地！"。带着众多头部兄弟的数据包，终于准
备要出门了。

### 7、网卡

网络包在计算机内存中只是一串**二进制数字**，无法直接在物理线路上进行传输。要真正将数据发送出去，必须将其转换为**电信号**，这一步由**网卡**负责。
负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。
### **网卡驱动的工作**

- **获取网络包**：网卡驱动程序从内存中获取已封装好的网络包。
- **复制到缓存区**：它将网络包复制到网卡内部的缓存区。
- **封装成帧**：在将网络包发送出去之前，网卡驱动会进行最终的封装：
    - **添加报头和起始帧分界符**：在数据包的最前面加上一个标记，用于表示帧的起始位置。
    - **添加帧校验序列（FCS）**：在数据包的末尾加上一段校验码，用于在接收端检查数据在传输过程中是否损坏。
### **网卡的工作**

- **转换信号**：封装完成后，网卡会将整个数据帧（包括 MAC 头部、IP 头部、TCP 头部等）从二进制数字转换为**电信号**。
- **发送数据**：最后，网卡通过网线将这些电信号发送到网络中。
![[Pasted image 20250920205749.png]]
真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目
的地的征途了!

### 8、交换机
交换机是一种工作在 **MAC 层**（也称为二层）的网络设备，它的主要任务是**原样转发**网络包到目的地。
### **1. 接收数据包**

- **物理接收**：交换机首先将网线上的电信号转换成数字信号。
- **校验与缓存**：它会检查数据包末尾的 **FCS**（帧校验序列）来确认数据是否完整。如果校验通过，它会将数据包存储到缓冲区中。
- **与网卡的区别**：与计算机网卡不同的是，交换机的每个端口**不具有 MAC 地址**，它会接收所有经过该端口的数据包，而不是只接收发给自己的。
### **2. 查询 MAC 地址表**

数据包被存入缓冲区后，交换机会读取数据包的**接收方 MAC 地址**，并在其内部的 **MAC 地址表**中进行查找。MAC 地址表包含两个关键信息：**设备的 MAC 地址**和它所连接的**交换机端口号**。
- **匹配成功**：如果找到了对应的 MAC 地址，交换机会将数据包只发送到该 MAC 地址所连接的端口，实现精确转发。
- **匹配失败**：如果 MAC 地址表中找不到记录，交换机会将数据包**广播**到**除源端口外的所有其他端口**。
### **3. 广播机制与效率**

当交换机无法找到 MAC 地址时，这种广播行为并不会造成网络拥塞，原因在于：
- **以太网设计**：以太网协议本身就允许将包发送到整个网络，最终只有目标设备会接收并处理它。
- **动态学习**：当目标设备收到广播包并作出响应时，交换机就会学习到它的 MAC 地址和端口号，并将其写入 MAC 地址表。下一次通信时，就可以直接进行单播（精确转发），大大提高了效率。
![[Pasted image 20250920205916.png]]
### **广播地址**
如果数据包的接收方 MAC 地址本身就是**广播地址**，交换机会将该数据包发送到除源端口外的所有端口。常见的广播地址有：
- **MAC 地址广播**：`FF:FF:FF:FF:FF:FF`
- **IP 地址广播**：`255.255.255.255`
数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别
时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！“

### 8、路由器
![[Pasted image 20250920210500.png]]

### **路由器的包转发工作原理**

路由器的包转发过程可以分为三个主要步骤：**接收**、**查询**和**发送**。

#### **1. 包接收操作**

- **接收电信号：** 网线接口将电信号转换为数字信号。
- **错误校验：** 利用数据包末尾的 **FCS (Frame Check Sequence)** 字段进行错误校验。
- **MAC地址检查：** 检查包的 **MAC 头部**，如果接收方 MAC 地址与路由器端口的 MAC 地址相匹配，则将包放入接收缓冲区；否则，直接丢弃该包。路由器端口只接收发给自己的以太网包。
#### **2. 查询路由表确定输出端口**

在接收到数据包后，路由器会开始进行转发操作。

- **剥离 MAC 头部：** 首先，路由器会丢弃数据包的 MAC 头部。因为 MAC 地址的作用是确保包能够从上一跳设备顺利到达路由器，其任务已完成。
- **路由表查询：** 路由器会根据 **IP 头部**中的 **接收方 IP 地址** 来查询**路由表**。
    - **匹配规则：** 将路由表中每个条目的**子网掩码**与数据包的**目标 IP 地址**进行按位“与”运算，得到的结果与该条目的**目标地址**进行匹配。
    - **寻找最佳匹配：** 如果匹配成功，该路由条目就成为一个候选转发目标。路由器会遍历所有条目，寻找最精确的匹配。
    - **默认路由：** 如果找不到任何匹配的路由条目，路由器会使用**默认路由**进行转发。路由表中子网掩码为 `0.0.0.0` 的条目通常表示默认路由。
#### **3. 包发送操作**

确定转发目标后，路由器会进行发送操作。

#### **1. 路由匹配与下一跳判断**

- **查找路由表：** 路由器首先会根据数据包的**目标IP地址**，在**路由表**中进行查询。
- **子网匹配：** 路由器会将路由表中每个条目的**子网掩码**与目标IP地址进行“与”运算，并与该条目的**目标地址**进行匹配。例如，如果目标IP是 `192.168.1.100`，子网掩码 `255.255.255.0` 经过运算后得到 `192.168.1.0`，如果路由表中存在目标地址为 `192.168.1.0` 的条目，则匹配成功。
- **默认路由：** 如果找不到任何匹配的路由，路由器将使用**默认路由**（子网掩码为 `0.0.0.0` 的条目）进行转发。
#### **2. 封装与发送**
- **判断网关：** 路由器会根据匹配到的路由条目中的**网关**列来确定下一跳地址。
    - 如果网关列有IP地址，说明数据包需要继续由下一个路由器转发。
    - 如果网关列为空，说明数据包已到达最终目的地所在的网络。
- **获取 MAC 地址：** 路由器会利用 **ARP协议**（优先从**ARP缓存**中查询）获取下一跳设备的MAC地址。
- **重新封装：** 路由器会丢弃旧的MAC头部，并封装一个新的MAC头部：
    - **发送方MAC地址**：填入路由器输出端口的MAC地址。
    - **接收方MAC地址**：填入下一跳设备的MAC地址。
- **发送：** 路由器将重新封装好的数据包转换为电信号，通过对应的端口发送出去，经由交换机到达下一个路由器或最终目的地。
![[Pasted image 20250920210256.png]]
在整个数据包的传输过程中，**源IP和目标IP始终不变**，而**MAC地址则在每一步转发时都会更新**，以确保数据包能在不同设备之间正确传递。

数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门
值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经
由城内的交换机帮助下，最终转发到了目的地了。数据包感慨万千的说道："多谢这一路上，各路大
侠的相助！＂

### 9、互相扒皮 服务器与客服端
![[Pasted image 20250920210934.png]]
### **服务器处理并返回响应的过程**

#### **1. 服务器接收并处理数据包**

当数据包到达服务器时，服务器的网卡会像拆快递一样，层层解封装数据包：

- **MAC层解封装**：服务器首先检查数据包的**MAC头部**，确认其目标MAC地址是否与自身网卡的MAC地址相符。如果相符，则接收该包。
    
- **IP层解封装**：接着，服务器剥离MAC头部，检查**IP头部**中的目标IP地址。如果地址符合，它会根据IP头部的**协议项**得知上层是TCP协议。
    
- **TCP层解封装**：服务器继续解封装**TCP头部**，检查其中的**序列号**和**端口号**。序列号用于确保数据包的顺序和完整性，如果序列号正确，数据会被存入缓存并返回一个ACK确认。端口号则让服务器知道应该将这个数据包交给哪个应用程序来处理，例如，交给正在监听该端口的**HTTP进程**。
    

#### **2. 服务器生成并发送响应**

HTTP进程处理完请求后，会生成一个HTTP响应报文，然后开始一层层封装，准备将数据发送回客户端：

- **HTTP封装**：服务器将网页内容封装在**HTTP响应报文**中。
    
- **TCP封装**：HTTP报文被封装进**TCP头部**。
    
- **IP封装**：TCP段被封装进**IP头部**，此时**源IP地址**是服务器的IP，**目标IP地址**是客户端的IP。
    
- **MAC封装**：最后，IP数据包被封装进**MAC头部**。此时**源MAC地址**是服务器网卡的MAC地址，而**目标MAC地址**是数据包即将发往的**下一跳路由器**的MAC地址。
    

#### **3. 响应数据包的返回旅程**

- **路由器转发**：封装好的数据包从服务器网卡发出，经过交换机到达出城（或出网）的路由器。路由器像之前一样，根据**路由表**将数据包层层转发给下一个路由器，**每经过一个路由器，MAC地址都会更新**。
    
- **抵达客户端**：数据包经过多次“跳跃”，最终到达客户端所在网络的**路由器**。该路由器剥离IP头部后，发现目标是城内的设备，便将包交给城内的**交换机**，由交换机根据**MAC地址表**最终转发给客户端。
    
#### **4. 客户端接收并渲染页面**

- **层层解封装**：客户端收到数据包后，会像服务器一样，一层层剥开包裹，从MAC头部、IP头部到TCP头部，最后得到**HTTP响应报文**。
    
- **浏览器渲染**：客户端的浏览器接收到HTTP响应报文后，开始解析并渲染页面，最终将网页内容呈现在用户眼前。

### **十、服务器处理请求**

服务器收到请求后，会按照以下流程进行处理：

1. Web 服务器接收请求：
    请求首先到达诸如 Nginx 或 Apache 等 Web 服务器。这些服务器扮演着“门卫”的角色，负责接收来自客户端的HTTP请求。
2. 请求转发到应用服务器：
    Web服务器会将请求转发给 应用服务器。应用服务器才是真正处理业务逻辑的地方，例如用 Java、Python 或 PHP 编写的后端服务。
3. 应用服务器执行业务逻辑：
    应用服务器根据请求内容，执行相应的业务逻辑。这可能包括查询数据库、访问缓存，或者进行其他复杂计算。
4. 构造 HTTP 响应并返回：
    业务逻辑执行完毕后，应用服务器会构造一个HTTP响应报文，其中包含了所需的数据（如HTML、JSON等），并将其返回给Web服务器，最终由Web服务器发回给客户端。
---

### **十一、服务器返回 HTTP 响应**

服务器会将处理好的**HTML、CSS、JS、图片**等资源封装在HTTP响应中，返回给浏览器。一个典型的HTTP响应报文包含状态行、响应头和响应体，例如：

```http
HTTP/1.1 200 OK
Content-Type: text/html

<html>
  <head><title>Example</title></head>
  <body>Hello World</body>
</html>
```

- `HTTP/1.1 200 OK`：状态行，表示请求成功。
    
- `Content-Type: text/html`：响应头，告知浏览器返回的是HTML内容。
    
- `<html>...</html>`：响应体，是浏览器即将渲染的实际内容。
---

### **六、浏览器渲染页面**

浏览器收到服务器返回的响应后，会开始解析和渲染页面。这是一个复杂且分阶段的过程：

1. 构建 DOM 树 (Document Object Model)：
    
    浏览器会解析HTML代码，将每个HTML标签转换为一个节点，并构建一个树形结构，这就是DOM树。
    
2. 构建 CSSOM 树 (CSS Object Model)：
    
    同时，浏览器会加载并解析CSS样式，为每个CSS选择器和规则构建一个树形结构，即CSSOM树。
    
3. 合成 Render Tree (渲染树)：
    
    浏览器将DOM树和CSSOM树合并，生成渲染树。渲染树只包含需要显示的节点及其对应的样式，不包含 display: none 等隐藏元素。
    
4. 布局 (Layout)：
    
    渲染树生成后，浏览器会根据其结构，计算页面上每个元素的位置和大小。
    
5. 绘制 (Paint)：
    
    布局完成后，浏览器会根据计算好的位置和大小，将每个元素绘制到屏幕上，如绘制文本、背景、边框等。
    
6. 合成 (Compositing)：
    
    如果页面包含多个图层（例如使用CSS3的 transform），浏览器会将其合成，最终显示到屏幕上。
    

> 💡 **请注意：** 在这个过程中，浏览器会**并发**地发送请求来加载页面中引用的其他资源，如图片、JS和CSS文件。

---

### **七、页面渲染优化**

为了加快页面加载和渲染速度，可以采取多种优化措施：

- 利用缓存：
    
    利用 HTTP缓存，通过设置响应头（如Cache-Control和Expires）来控制浏览器是否缓存资源。如果资源未过期，浏览器可以直接使用缓存，无需再次向服务器请求。当服务器资源更新时，可以使用 304 Not Modified 状态码来告诉浏览器，本地缓存版本仍然可用，从而减少数据传输。
    
- CDN 加速 (Content Delivery Network)：
    
    将静态资源（如图片、JS、CSS）分发到全球各地的CDN节点。当用户请求这些资源时，CDN会选择最近的节点进行响应，显著减少网络延迟，提高加载速度。
    
- 懒加载 (Lazy Load)：
    
    延迟加载非首屏或不重要的图片等资源，直到它们即将进入用户可视区域时才加载。这可以减少首次加载的资源量，加快页面打开速度。
    
- JS/CSS 压缩与合并：
    
    通过压缩（移除空格、注释等）和合并（将多个小文件合并成一个大文件）JS和CSS文件，可以减少文件大小和HTTP请求次数，从而加快加载速度。
    
